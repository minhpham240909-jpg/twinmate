// Clerva 2.0 - Prisma Schema
// Database: PostgreSQL via Supabase

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions"]
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL") // Enable for migrations
  // extensions = [vector] // Enable later for AI embeddings
}

// ==========================================
// USER & AUTH
// ==========================================

enum UserRole {
  FREE
  PREMIUM
}

enum OnlineStatus {
  ONLINE
  BUSY
  OFFLINE
  LOOKING_FOR_PARTNER
}

enum SkillLevel {
  BEGINNER
  INTERMEDIATE
  ADVANCED
  EXPERT
}

enum StudyStyle {
  VISUAL
  AUDITORY
  KINESTHETIC
  READING_WRITING
  COLLABORATIVE
  INDEPENDENT
  SOLO
  MIXED
}

model User {
  id            String   @id @default(uuid())
  email         String   @unique
  passwordHash  String? // null if OAuth only
  name          String
  avatarUrl     String?
  coverPhotoUrl String?
  role          UserRole @default(FREE)
  emailVerified Boolean  @default(false)

  // OAuth
  googleId String? @unique

  // Stripe
  stripeCustomerId     String?   @unique
  stripeSubscriptionId String?
  subscriptionStatus   String? // active, canceled, past_due, etc.
  subscriptionEndsAt   DateTime?

  // Account Deactivation
  deactivatedAt DateTime? // When account was deactivated (null if active)
  deactivationReason String? @db.Text // Optional reason for deactivation

  // Two-Factor Authentication
  twoFactorEnabled Boolean @default(false)
  twoFactorSecret String? // TOTP secret (encrypted)
  twoFactorBackupCodes String[] @default([]) // Backup codes for recovery

  // Timestamps
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  lastLoginAt DateTime?

  // Relations
  profile               Profile?
  learningProfile       LearningProfile?
  settings              UserSettings?
  sentMatches           Match[]              @relation("SentMatches")
  receivedMatches       Match[]              @relation("ReceivedMatches")
  sentMessages          Message[]            @relation("SentMessages")
  groupMemberships      GroupMember[]
  sessions              Session[]
  badges                UserBadge[]
  studySessions         StudySession[]       @relation("SessionUser")
  createdSessions       StudySession[]       @relation("SessionCreator")
  sessionParticipations SessionParticipant[]
  sessionMessages       SessionMessage[]
  notifications         Notification[]
  posts                 Post[]
  postLikes             PostLike[]
  postComments          PostComment[]
  postReposts           PostRepost[]
  blockedUsers          BlockedUser[]        @relation("UserBlocks")
  blockedByUsers        BlockedUser[]        @relation("BlockedByUser")
  sessionFlashcards     SessionFlashcard[]

  // Presence system relations
  presence              UserPresence?
  deviceSessions        DeviceSession[]
  messageReadStatus     MessageReadStatus[]
  typingIndicators      TypingIndicator[]

  @@index([email])
  @@index([googleId])
  @@index([role])
  @@index([deactivatedAt])
  @@index([twoFactorEnabled])
}

model Profile {
  id     String @id @default(uuid())
  userId String @unique
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Core profile
  bio       String? @db.Text
  age       Int? // User's age
  role      String? // User's role/position (e.g., "Student", "Graduate Student", "Software Engineer")
  timezone  String?

  // DEPRECATED: Old location fields (keep for backward compatibility)
  location  String?
  latitude  Float?
  longitude Float?

  // NEW: Hybrid Location System
  location_city          String? // City from auto-detect or manual entry
  location_state         String? // State/region from auto-detect or manual entry
  location_country       String? // Country from auto-detect or manual entry
  location_lat           Float? // Latitude for proximity matching (privacy-safe)
  location_lng           Float? // Longitude for proximity matching (privacy-safe)
  location_visibility    String  @default("match-only") // 'private', 'match-only', or 'public'
  location_last_updated  DateTime? // When location was last updated

  // Academic/Learning
  subjects   String[] // ["Math", "Physics", "CS"]
  interests  String[] // ["ML", "Gaming", "Music"]
  goals      String[] // ["Prep for SAT", "Build portfolio"]
  skillLevel SkillLevel? // Optional
  studyStyle StudyStyle? // Optional
  school     String? @db.Text // Custom school name
  languages  String? @db.Text // Custom languages (comma-separated or free text)

  // Availability
  availableDays  String[] // ["Monday", "Wednesday"]
  availableHours String[] // ["18:00-20:00", "09:00-12:00"]

  // Custom Descriptions for Partner Search
  subjectCustomDescription      String? @db.Text
  skillLevelCustomDescription   String? @db.Text
  studyStyleCustomDescription   String? @db.Text
  interestsCustomDescription    String? @db.Text
  availabilityCustomDescription String? @db.Text

  // NEW: Add more about yourself
  aboutYourselfItems String[] @default([]) // Custom tags/items
  aboutYourself      String?  @db.Text // Detailed description

  // Status
  onlineStatus        OnlineStatus @default(OFFLINE)
  isLookingForPartner Boolean      @default(false)

  // Privacy
  showLocation Boolean @default(false)
  showEmail    Boolean @default(false)

  // Community Settings
  postPrivacy PostPrivacy @default(PUBLIC)

  // Gamification
  studyStreak     Int       @default(0)
  totalStudyHours Float     @default(0)
  lastStudyDate   DateTime?

  // Notifications
  emailNotifications Boolean @default(true)
  pushNotifications  Boolean @default(true)

  // AI embeddings for semantic matching (enable with pgvector extension)
  embedding Unsupported("vector(1536)")? // OpenAI text-embedding-3-small dimension

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([subjects])
  @@index([interests])
  @@index([onlineStatus])
  @@index([location_city])
  @@index([location_visibility])
}

model LearningProfile {
  id     String @id @default(uuid())
  userId String @unique
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Strengths and Weaknesses for Partner Matching
  strengths        String[] @default([]) // Topics/skills user excels at: ["Calculus", "Essay Writing", "Programming"]
  weaknesses       String[] @default([]) // Topics/skills user struggles with: ["Statistics", "Grammar", "Algorithms"]
  recommendedFocus String[] @default([]) // AI-generated recommendations: ["Practice word problems", "Review theorems"]

  // Analytics (from buildLearningProfile tool)
  analytics      Json?     // Performance breakdown, topic averages, etc.
  lastComputedAt DateTime? // When the profile was last analyzed

  // Learning Metrics (for future analytics)
  learningVelocity    Float?  @default(1.0) // How fast they learn (0.5 = slow, 2.0 = fast)
  retentionRate       Float?  @default(0.7) // How well they retain info (0-1 scale)
  preferredDifficulty String? // "easy", "medium", "hard", "adaptive"

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([strengths])
  @@index([weaknesses])
}

// ==========================================
// MATCHING & CONNECTIONS
// ==========================================

enum MatchStatus {
  PENDING
  ACCEPTED
  REJECTED
  CANCELLED
}

model Match {
  id String @id @default(uuid())

  senderId String
  sender   User   @relation("SentMatches", fields: [senderId], references: [id], onDelete: Cascade)

  receiverId String
  receiver   User   @relation("ReceivedMatches", fields: [receiverId], references: [id], onDelete: Cascade)

  status  MatchStatus @default(PENDING)
  message String?     @db.Text

  // AI Match Score
  compatibilityScore Float? // 0-100
  matchReason        String? @db.Text // AI-generated explanation

  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  respondedAt DateTime?

  @@unique([senderId, receiverId])
  @@index([senderId, status])
  @@index([receiverId, status])
}

// ==========================================
// GROUPS
// ==========================================

enum GroupPrivacy {
  PUBLIC
  PRIVATE
  INVITE_ONLY
}

model Group {
  id                          String       @id @default(uuid())
  name                        String
  description                 String?      @db.Text
  subject                     String
  subjectCustomDescription    String?      @db.Text
  skillLevel                  String? // Beginner, Intermediate, Advanced, Expert
  skillLevelCustomDescription String?      @db.Text
  avatarUrl                   String?
  privacy                     GroupPrivacy @default(PUBLIC)
  maxMembers                  Int          @default(10)

  ownerId String

  // Soft delete fields
  isDeleted Boolean   @default(false)
  deletedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  members  GroupMember[]
  messages Message[]
  invites  GroupInvite[]

  @@index([subject])
  @@index([privacy])
  @@index([ownerId])
  @@index([isDeleted])
  @@index([deletedAt])
}

enum MemberRole {
  OWNER
  ADMIN
  MEMBER
}

model GroupMember {
  id String @id @default(uuid())

  groupId String
  group   Group  @relation(fields: [groupId], references: [id], onDelete: Cascade)

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  role MemberRole @default(MEMBER)

  joinedAt DateTime @default(now())

  @@unique([groupId, userId])
  @@index([userId])
  @@index([groupId])
}

enum InviteStatus {
  PENDING
  ACCEPTED
  DECLINED
}

model GroupInvite {
  id String @id @default(uuid())

  groupId String
  group   Group  @relation(fields: [groupId], references: [id], onDelete: Cascade)

  inviterId String // User who sent the invite
  inviteeId String // User who received the invite

  status  InviteStatus @default(PENDING)
  message String?      @db.Text

  createdAt   DateTime  @default(now())
  respondedAt DateTime?

  @@unique([groupId, inviteeId])
  @@index([inviteeId, status])
  @@index([groupId])
}

// ==========================================
// MESSAGING
// ==========================================

enum MessageType {
  TEXT
  IMAGE
  FILE
  SYSTEM
  CALL
}

enum CallType {
  AUDIO
  VIDEO
}

enum CallStatus {
  STARTED
  COMPLETED
  MISSED
  CANCELLED
  DECLINED
}

model Message {
  id      String      @id @default(uuid())
  content String      @db.Text
  type    MessageType @default(TEXT)

  senderId String
  sender   User   @relation("SentMessages", fields: [senderId], references: [id], onDelete: Cascade)

  // Either DM or Group message
  groupId String?
  group   Group?  @relation(fields: [groupId], references: [id], onDelete: Cascade)

  recipientId String? // For DMs

  // Attachments
  fileUrl  String?
  fileName String?
  fileSize Int?

  // Status
  isRead      Boolean   @default(false)
  readAt      DateTime?
  deliveredAt DateTime? // New field for delivery status
  isEdited    Boolean   @default(false)

  // Call metadata (only for CALL type messages)
  callType      CallType?
  callDuration  Int? // Duration in seconds
  callStatus    CallStatus?
  callStartedAt DateTime?

  // Soft delete fields
  isDeleted Boolean   @default(false)
  deletedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Presence system relations
  readBy        MessageReadStatus[]

  // Individual indexes
  @@index([senderId])
  @@index([groupId])
  @@index([recipientId])
  @@index([createdAt])
  @@index([deliveredAt]) // New index for delivery status
  @@index([isDeleted])
  @@index([deletedAt])
  // Critical composite indexes for performance
  @@index([senderId, recipientId, createdAt]) // DM message loading
  @@index([groupId, createdAt]) // Group message loading
  @@index([recipientId, isRead]) // Unread count queries for DMs
  @@index([groupId, isRead]) // Unread count queries for groups
  @@index([senderId, recipientId, groupId]) // Message filtering
}

// New model for per-user conversation archives
model ConversationArchive {
  id               String    @id @default(uuid())
  userId           String
  conversationType String // 'partner' or 'group'
  conversationId   String // partner userId or groupId
  isArchived       Boolean   @default(false)
  archivedAt       DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, conversationType, conversationId])
  @@index([userId])
  @@index([conversationId])
}

// ==========================================
// STUDY SESSIONS
// ==========================================

enum SessionType {
  SOLO
  ONE_ON_ONE
  GROUP
}

enum SessionStatus {
  WAITING    // New: Waiting lobby state (30 min timeout)
  SCHEDULED  // Legacy: kept for backward compatibility
  ACTIVE     // Call is in progress
  COMPLETED  // Call has ended
  CANCELLED  // Call was cancelled
}

enum SessionRole {
  HOST
  CO_HOST
  PARTICIPANT
}

enum ParticipantStatus {
  INVITED
  JOINED
  LEFT
  REMOVED
}

model StudySession {
  id          String        @id @default(uuid())
  title       String
  description String?       @db.Text
  type        SessionType
  status      SessionStatus @default(WAITING) // Start in waiting lobby

  // Creator/Host
  createdBy String
  creator   User   @relation("SessionCreator", fields: [createdBy], references: [id], onDelete: Cascade)

  // Legacy field (keep for backward compatibility)
  userId String
  user   User   @relation("SessionUser", fields: [userId], references: [id], onDelete: Cascade)

  // Session Metadata
  subject         String?
  tags            String[] @default([])
  maxParticipants Int      @default(10)
  isPublic        Boolean  @default(false)

  // Timing
  scheduledAt       DateTime?
  waitingStartedAt  DateTime  @default(now()) // When waiting lobby was created
  waitingExpiresAt  DateTime? // Auto-calculated: waitingStartedAt + 30 minutes
  startedAt         DateTime? // When call actually started (null until "Start" is clicked)
  endedAt           DateTime?
  durationMinutes   Int?

  // AI-generated summary
  aiSummary   String?  @db.Text
  aiKeyPoints String[] @default([])
  aiTodos     String[] @default([])

  // Video/Audio room
  roomId       String?
  agoraChannel String? @unique
  recordingUrl String?

  // Relations
  participants SessionParticipant[]
  goals        SessionGoal[]
  messages     SessionMessage[]
  timer        SessionTimer?
  whiteboard   SessionWhiteboard?
  notes        SessionNote[]
  flashcards   SessionFlashcard[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([createdBy])
  @@index([userId])
  @@index([status])
  @@index([type])
  @@index([startedAt])
  @@index([agoraChannel])
}

model SessionParticipant {
  id        String       @id @default(uuid())
  sessionId String
  session   StudySession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  role   SessionRole       @default(PARTICIPANT)
  status ParticipantStatus @default(INVITED)

  joinedAt  DateTime?
  leftAt    DateTime?
  createdAt DateTime  @default(now())

  @@unique([sessionId, userId])
  @@index([userId])
  @@index([sessionId])
  @@index([status])
}

model SessionGoal {
  id        String       @id @default(uuid())
  sessionId String
  session   StudySession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  title       String
  description String?   @db.Text
  isCompleted Boolean   @default(false)
  completedAt DateTime?
  order       Int       @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([sessionId])
}

model SessionMessage {
  id        String       @id @default(uuid())
  sessionId String
  session   StudySession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  senderId String
  sender   User   @relation(fields: [senderId], references: [id], onDelete: Cascade)

  content String      @db.Text
  type    MessageType @default(TEXT)

  createdAt DateTime @default(now())
  deletedAt DateTime?

  @@index([sessionId])
  @@index([senderId])
  @@index([createdAt])
  @@index([deletedAt])
}

enum TimerState {
  IDLE
  RUNNING
  PAUSED
  BREAK
  BREAK_PAUSED
}

model SessionTimer {
  id        String       @id @default(uuid())
  sessionId String       @unique
  session   StudySession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  // Timer Settings
  studyDuration Int // Study duration in minutes
  breakDuration Int // Break duration in minutes

  // Current State
  state         TimerState @default(IDLE)
  timeRemaining Int // Remaining seconds
  currentCycle  Int        @default(1) // Study Session 1, 2, 3...
  isBreakTime   Boolean    @default(false)

  // Tracking
  lastStartedAt  DateTime?
  lastPausedAt   DateTime?
  totalStudyTime Int       @default(0) // Total study seconds accumulated
  totalBreakTime Int       @default(0) // Total break seconds accumulated

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([sessionId])
}

// ==========================================
// GAMIFICATION
// ==========================================

enum BadgeType {
  STUDY_STREAK
  HOURS_LOGGED
  PARTNERSHIPS
  QUIZZES_PASSED
  SPECIAL
}

model Badge {
  id          String    @id @default(uuid())
  name        String    @unique
  description String
  type        BadgeType
  iconUrl     String
  requirement Int // e.g., 7 for 7-day streak

  users UserBadge[]

  @@index([type])
}

model UserBadge {
  id String @id @default(uuid())

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  badgeId String
  badge   Badge  @relation(fields: [badgeId], references: [id], onDelete: Cascade)

  earnedAt DateTime @default(now())

  @@unique([userId, badgeId])
  @@index([userId])
}

// ==========================================
// NOTIFICATIONS
// ==========================================

enum NotificationType {
  MATCH_REQUEST
  MATCH_ACCEPTED
  MATCH_DECLINED
  NEW_MESSAGE
  GROUP_INVITE
  GROUP_REMOVED
  STUDY_REMINDER
  BADGE_EARNED
  STREAK_REMINDER
  CONNECTION_REQUEST
  CONNECTION_ACCEPTED
  CONNECTION_DECLINED
  SESSION_INVITE
  SESSION_STARTED
  SESSION_JOINED
  SESSION_ENDED
  SESSION_GOAL_COMPLETED
  INCOMING_CALL
}

model Notification {
  id String @id @default(uuid())

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  type    NotificationType
  title   String
  message String           @db.Text

  isRead    Boolean @default(false)
  actionUrl String?

  // Reference to related entities
  relatedUserId  String? // ID of the user who triggered the notification
  relatedMatchId String? // ID of the match/connection request

  createdAt DateTime @default(now())

  @@index([userId, isRead])
  @@index([createdAt])
}

// ==========================================
// SESSIONS (NextAuth)
// ==========================================

model Session {
  id     String @id @default(uuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  token     String   @unique
  expiresAt DateTime

  createdAt DateTime @default(now())

  @@index([userId])
  @@index([token])
}

// ==========================================
// COMMUNITY (Social Feed like X/Twitter)
// ==========================================

enum PostPrivacy {
  PUBLIC         // Everyone can see
  PARTNERS_ONLY  // Only connected partners can see
}

model Post {
  id      String @id @default(uuid())
  userId  String
  user    User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  content   String  @db.Text // Post text content
  imageUrls String[] // Array of image URLs
  postUrl   String? // Optional link/URL to external content

  // Soft delete fields
  isDeleted Boolean   @default(false) // Soft delete flag
  deletedAt DateTime? // When post was deleted (null if not deleted)

  // Share settings
  allowSharing Boolean @default(true) // Allow post to be shared outside the app

  // Relations
  likes    PostLike[]
  comments PostComment[]
  reposts  PostRepost[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([createdAt])
  @@index([isDeleted])
  @@index([deletedAt])
}

model PostLike {
  id     String @id @default(uuid())
  postId String
  post   Post   @relation(fields: [postId], references: [id], onDelete: Cascade)
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([postId, userId]) // User can only like a post once
  @@index([postId])
  @@index([userId])
}

model PostComment {
  id      String @id @default(uuid())
  postId  String
  post    Post   @relation(fields: [postId], references: [id], onDelete: Cascade)
  userId  String
  user    User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  content String @db.Text

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([postId])
  @@index([userId])
  @@index([createdAt])
}

model PostRepost {
  id      String  @id @default(uuid())
  postId  String
  post    Post    @relation(fields: [postId], references: [id], onDelete: Cascade)
  userId  String
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  comment String? @db.Text // Optional comment for "quote repost"

  createdAt DateTime @default(now())

  @@unique([postId, userId]) // User can only repost once
  @@index([postId])
  @@index([userId])
  @@index([createdAt])
}

// ==========================================
// USER SETTINGS
// ==========================================

enum ProfileVisibility {
  EVERYONE
  CONNECTIONS_ONLY
  PRIVATE
}

enum DataSharing {
  MINIMAL
  STANDARD
  FULL
}

enum NotificationFrequency {
  REALTIME
  DIGEST_DAILY
  DIGEST_WEEKLY
  OFF
}

enum FlashcardFrequency {
  DAILY
  WEEKLY
  CUSTOM
}

enum VideoQuality {
  AUTO
  LOW
  MEDIUM
  HIGH
}

enum SessionInvitePrivacy {
  EVERYONE
  CONNECTIONS
  NOBODY
}

enum GroupPrivacyDefault {
  PUBLIC
  PRIVATE
  INVITE_ONLY
}

enum FeedAlgorithm {
  RECOMMENDED
  CHRONOLOGICAL
  TRENDING
}

enum CommentPrivacy {
  EVERYONE
  CONNECTIONS
  NOBODY
}

enum Theme {
  LIGHT
  DARK
  SYSTEM
}

enum FontSize {
  SMALL
  MEDIUM
  LARGE
  XLARGE
}

enum ColorBlindMode {
  NONE
  PROTANOPIA
  DEUTERANOPIA
  TRITANOPIA
}

enum PerformanceMode {
  LOW_POWER
  BALANCED
  PERFORMANCE
}

model UserSettings {
  id     String @id @default(uuid())
  userId String @unique
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Account & Profile
  language String? @default("en")
  timezone String? @default("UTC")

  // Privacy & Visibility
  profileVisibility ProfileVisibility @default(EVERYONE)
  searchVisibility  Boolean           @default(true)
  showOnlineStatus  Boolean           @default(true)
  showLastSeen      Boolean           @default(true)
  dataSharing       DataSharing       @default(STANDARD)

  // Notification Preferences - In-App
  notifyConnectionRequests Boolean @default(true)
  notifyConnectionAccepted Boolean @default(true)
  notifySessionInvites     Boolean @default(true)
  notifyGroupInvites       Boolean @default(true)
  notifyMessages           Boolean @default(true)
  notifyMissedCalls        Boolean @default(true)
  notifyCommunityActivity  Boolean @default(true)
  notifySessionReminders   Boolean @default(true)

  // Email Notifications
  emailConnectionRequests Boolean @default(true)
  emailSessionInvites     Boolean @default(true)
  emailMessages           Boolean @default(false)
  emailWeeklySummary      Boolean @default(true)

  // Notification Frequency
  notificationFrequency NotificationFrequency @default(REALTIME)

  // Do Not Disturb
  doNotDisturbEnabled Boolean @default(false)
  doNotDisturbStart   String? // e.g., "22:00"
  doNotDisturbEnd     String? // e.g., "08:00"

  // Study Preferences
  defaultStudyDuration     Int                 @default(25) // minutes
  defaultBreakDuration     Int                 @default(5) // minutes
  preferredSessionLength   Int                 @default(60) // minutes
  autoGenerateQuizzes      Boolean             @default(false)
  flashcardReviewFrequency FlashcardFrequency? @default(DAILY)

  // Communication Settings
  messageReadReceipts    Boolean      @default(true)
  typingIndicators       Boolean      @default(true)
  autoDownloadMedia      Boolean      @default(true)
  videoQuality           VideoQuality @default(AUTO)
  audioQuality           VideoQuality @default(AUTO)
  enableVirtualBackground Boolean     @default(false)

  // Call Settings
  autoAnswerFromPartners Boolean @default(false)
  callRingtone           String? @default("default")

  // Study Session Settings
  autoStartTimer           Boolean               @default(false)
  breakReminders           Boolean               @default(true)
  sessionHistoryRetention  Int                   @default(90) // days
  sessionInvitePrivacy     SessionInvitePrivacy  @default(EVERYONE)

  // Group Settings
  defaultGroupPrivacy  GroupPrivacyDefault   @default(PUBLIC)
  groupNotifications   Boolean               @default(true)
  autoJoinMatchingGroups Boolean             @default(false)
  groupInvitePrivacy   SessionInvitePrivacy  @default(EVERYONE)

  // Content & Community
  feedAlgorithm       FeedAlgorithm  @default(RECOMMENDED)
  showTrendingTopics  Boolean        @default(true)
  commentPrivacy      CommentPrivacy @default(EVERYONE)
  tagPrivacy          CommentPrivacy @default(EVERYONE)
  contentFiltering    String[]       @default([])

  // Accessibility
  theme           Theme           @default(SYSTEM)
  fontSize        FontSize        @default(MEDIUM)
  highContrast    Boolean         @default(false)
  reducedMotion   Boolean         @default(false)
  keyboardShortcuts Boolean       @default(true)
  colorBlindMode  ColorBlindMode  @default(NONE)

  // Data & Storage
  cacheEnabled       Boolean @default(true)
  autoBackup         Boolean @default(true)
  storageUsageLimit  Int     @default(1000) // MB

  // Integrations
  googleCalendarSync Boolean @default(false)
  googleCalendarId   String?

  // Advanced
  developerMode     Boolean         @default(false)
  betaFeatures      Boolean         @default(false)
  performanceMode   PerformanceMode @default(BALANCED)
  analyticsEnabled  Boolean         @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
}

// Blocked Users for Privacy
model BlockedUser {
  id            String @id @default(uuid())
  userId        String
  user          User   @relation("UserBlocks", fields: [userId], references: [id], onDelete: Cascade)
  blockedUserId String
  blockedUser   User   @relation("BlockedByUser", fields: [blockedUserId], references: [id], onDelete: Cascade)
  reason        String?

  createdAt DateTime @default(now())

  @@unique([userId, blockedUserId])
  @@index([userId])
  @@index([blockedUserId])
}

// ==========================================
// STUDY SESSION COLLABORATION FEATURES
// ==========================================

// Whiteboard - Real-time collaborative drawing
model SessionWhiteboard {
  id        String       @id @default(uuid())
  sessionId String       @unique
  session   StudySession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  // Metadata
  title       String @default("Untitled Whiteboard")
  description String?

  // Storage references (Supabase Storage)
  snapshotUrl  String? // URL to latest full whiteboard snapshot
  thumbnailUrl String? // Small preview thumbnail

  // Real-time sync metadata
  lastSyncedAt  DateTime @default(now())
  lastEditedBy  String? // User ID who last edited
  version       Int      @default(1)

  // Relations
  versions SessionWhiteboardVersion[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([sessionId])
  @@index([lastSyncedAt])
}

// Whiteboard version history
model SessionWhiteboardVersion {
  id           String            @id @default(uuid())
  whiteboardId String
  whiteboard   SessionWhiteboard @relation(fields: [whiteboardId], references: [id], onDelete: Cascade)

  version     Int    // Version number (incremental)
  snapshotUrl String // Supabase Storage URL for this version
  createdBy   String // User ID who created this version

  createdAt DateTime @default(now())

  @@index([whiteboardId])
  @@index([whiteboardId, version])
  @@index([createdAt])
}

// Shared Notes - Real-time collaborative note-taking
model SessionNote {
  id        String       @id @default(uuid())
  sessionId String       @unique
  session   StudySession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  // Metadata
  title String @default("Untitled Note")

  // Content (stored in DB if < 64KB, otherwise in Storage)
  content    String? @db.Text // Null if stored in Storage
  contentUrl String? // Supabase Storage URL for large content

  // Real-time sync
  lastEditedBy String? // User ID
  lastEditedAt DateTime @default(now())

  // Versioning
  version Int @default(1)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([sessionId])
  @@index([lastEditedAt])
}

// Flashcards - Per-user study cards with spaced repetition
model SessionFlashcard {
  id        String       @id @default(uuid())
  sessionId String
  session   StudySession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  userId String // Per-user flashcards (not shared)
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Card content
  front String @db.Text
  back  String @db.Text

  // Study tracking
  difficulty     Int       @default(0) // 0=easy, 1=medium, 2=hard
  lastReviewed   DateTime?
  reviewCount    Int       @default(0)
  correctCount   Int       @default(0)
  incorrectCount Int       @default(0)

  // Spaced repetition (SM-2 algorithm)
  nextReviewDate DateTime? // When this card should be reviewed next
  intervalDays   Int       @default(1) // Current interval in days
  easeFactor     Float     @default(2.5) // SM-2 ease factor (2.5 is default)
  repetitions    Int       @default(0) // Number of successful reviews in a row

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([sessionId, userId, id])
  @@index([sessionId, userId])
  @@index([userId, nextReviewDate]) // For querying due cards
  @@index([createdAt])
}

// ==========================================
// PRESENCE SYSTEM (Real-time Online/Offline Tracking)
// ==========================================

// Aggregate user presence status (one per user)
model UserPresence {
  id              String   @id @default(uuid())
  userId          String   @unique
  status          String   @default("offline") // "online" | "away" | "offline"
  lastSeenAt      DateTime @default(now())
  lastActivityAt  DateTime @default(now())
  isPrivate       Boolean  @default(false) // Privacy setting: hide online status
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([status])
  @@map("user_presence")
}

// Individual device/tab sessions (multiple per user)
model DeviceSession {
  id              String   @id @default(uuid())
  userId          String
  deviceId        String   // Client-generated UUID (persists across refreshes in localStorage)
  lastHeartbeatAt DateTime @default(now())
  isActive        Boolean  @default(true)
  userAgent       String?  // Browser/device info
  ipAddress       String?  // For security logging
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, deviceId])
  @@index([userId, isActive])
  @@index([lastHeartbeatAt])
  @@map("device_sessions")
}

// Message read receipts
model MessageReadStatus {
  id          String   @id @default(uuid())
  messageId   String
  userId      String   // Who read the message
  readAt      DateTime @default(now())
  createdAt   DateTime @default(now())

  // Relations
  message     Message  @relation(fields: [messageId], references: [id], onDelete: Cascade)
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([messageId, userId])
  @@index([messageId])
  @@index([userId])
  @@map("message_read_status")
}

// Typing indicators (short-lived, auto-expire after 10s)
model TypingIndicator {
  id             String   @id @default(uuid())
  userId         String   // Who is typing
  conversationId String   // Where they're typing (chatId or studySessionId)
  isTyping       Boolean  @default(true)
  expiresAt      DateTime // Auto-delete after 10 seconds
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  // Relations
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, conversationId])
  @@index([conversationId, expiresAt])
  @@map("typing_indicators")
}

// ==========================================
// RLS POLICIES (SQL to be run after migration)
// ==========================================
//
// -- Enable RLS on all collaboration tables
// ALTER TABLE "SessionWhiteboard" ENABLE ROW LEVEL SECURITY;
// ALTER TABLE "SessionWhiteboardVersion" ENABLE ROW LEVEL SECURITY;
// ALTER TABLE "SessionNote" ENABLE ROW LEVEL SECURITY;
// ALTER TABLE "SessionFlashcard" ENABLE ROW LEVEL SECURITY;
//
// -- SessionWhiteboard RLS: Users can only access whiteboards for sessions they're participants in
// CREATE POLICY "Users can view whiteboards for their sessions"
//   ON "SessionWhiteboard" FOR SELECT
//   USING (
//     EXISTS (
//       SELECT 1 FROM "SessionParticipant"
//       WHERE "SessionParticipant"."sessionId" = "SessionWhiteboard"."sessionId"
//       AND "SessionParticipant"."userId" = auth.uid()::text
//     )
//   );
//
// CREATE POLICY "Users can update whiteboards for their sessions"
//   ON "SessionWhiteboard" FOR UPDATE
//   USING (
//     EXISTS (
//       SELECT 1 FROM "SessionParticipant"
//       WHERE "SessionParticipant"."sessionId" = "SessionWhiteboard"."sessionId"
//       AND "SessionParticipant"."userId" = auth.uid()::text
//     )
//   );
//
// CREATE POLICY "Session hosts can insert whiteboards"
//   ON "SessionWhiteboard" FOR INSERT
//   WITH CHECK (
//     EXISTS (
//       SELECT 1 FROM "StudySession"
//       WHERE "StudySession"."id" = "SessionWhiteboard"."sessionId"
//       AND "StudySession"."createdBy" = auth.uid()::text
//     )
//   );
//
// CREATE POLICY "Session hosts can delete whiteboards"
//   ON "SessionWhiteboard" FOR DELETE
//   USING (
//     EXISTS (
//       SELECT 1 FROM "StudySession"
//       WHERE "StudySession"."id" = "SessionWhiteboard"."sessionId"
//       AND "StudySession"."createdBy" = auth.uid()::text
//     )
//   );
//
// -- SessionWhiteboardVersion RLS
// CREATE POLICY "Users can view whiteboard versions for their sessions"
//   ON "SessionWhiteboardVersion" FOR SELECT
//   USING (
//     EXISTS (
//       SELECT 1 FROM "SessionWhiteboard" wb
//       INNER JOIN "SessionParticipant" sp ON wb."sessionId" = sp."sessionId"
//       WHERE wb."id" = "SessionWhiteboardVersion"."whiteboardId"
//       AND sp."userId" = auth.uid()::text
//     )
//   );
//
// CREATE POLICY "Users can create whiteboard versions for their sessions"
//   ON "SessionWhiteboardVersion" FOR INSERT
//   WITH CHECK (
//     EXISTS (
//       SELECT 1 FROM "SessionWhiteboard" wb
//       INNER JOIN "SessionParticipant" sp ON wb."sessionId" = sp."sessionId"
//       WHERE wb."id" = "SessionWhiteboardVersion"."whiteboardId"
//       AND sp."userId" = auth.uid()::text
//     )
//   );
//
// -- SessionNote RLS: Similar to whiteboard
// CREATE POLICY "Users can view notes for their sessions"
//   ON "SessionNote" FOR SELECT
//   USING (
//     EXISTS (
//       SELECT 1 FROM "SessionParticipant"
//       WHERE "SessionParticipant"."sessionId" = "SessionNote"."sessionId"
//       AND "SessionParticipant"."userId" = auth.uid()::text
//     )
//   );
//
// CREATE POLICY "Users can update notes for their sessions"
//   ON "SessionNote" FOR UPDATE
//   USING (
//     EXISTS (
//       SELECT 1 FROM "SessionParticipant"
//       WHERE "SessionParticipant"."sessionId" = "SessionNote"."sessionId"
//       AND "SessionParticipant"."userId" = auth.uid()::text
//     )
//   );
//
// CREATE POLICY "Session hosts can insert notes"
//   ON "SessionNote" FOR INSERT
//   WITH CHECK (
//     EXISTS (
//       SELECT 1 FROM "StudySession"
//       WHERE "StudySession"."id" = "SessionNote"."sessionId"
//       AND "StudySession"."createdBy" = auth.uid()::text
//     )
//   );
//
// CREATE POLICY "Session hosts can delete notes"
//   ON "SessionNote" FOR DELETE
//   USING (
//     EXISTS (
//       SELECT 1 FROM "StudySession"
//       WHERE "StudySession"."id" = "SessionNote"."sessionId"
//       AND "StudySession"."createdBy" = auth.uid()::text
//     )
//   );
//
// -- SessionFlashcard RLS: Users can only access their own flashcards
// CREATE POLICY "Users can view their own flashcards"
//   ON "SessionFlashcard" FOR SELECT
//   USING ("userId" = auth.uid()::text);
//
// CREATE POLICY "Users can insert their own flashcards"
//   ON "SessionFlashcard" FOR INSERT
//   WITH CHECK (
//     "userId" = auth.uid()::text
//     AND EXISTS (
//       SELECT 1 FROM "SessionParticipant"
//       WHERE "SessionParticipant"."sessionId" = "SessionFlashcard"."sessionId"
//       AND "SessionParticipant"."userId" = auth.uid()::text
//     )
//   );
//
// CREATE POLICY "Users can update their own flashcards"
//   ON "SessionFlashcard" FOR UPDATE
//   USING ("userId" = auth.uid()::text);
//
// CREATE POLICY "Users can delete their own flashcards"
//   ON "SessionFlashcard" FOR DELETE
//   USING ("userId" = auth.uid()::text);
