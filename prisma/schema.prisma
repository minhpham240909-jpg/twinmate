// Clerva 2.0 - Prisma Schema
// Database: PostgreSQL via Supabase

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions"]
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL") // Enable for migrations
  // extensions = [vector] // Enable later for AI embeddings
}

// ==========================================
// USER & AUTH
// ==========================================

enum UserRole {
  FREE
  PREMIUM
}

enum OnlineStatus {
  ONLINE
  BUSY
  OFFLINE
  LOOKING_FOR_PARTNER
}

enum SkillLevel {
  BEGINNER
  INTERMEDIATE
  ADVANCED
  EXPERT
}

enum StudyStyle {
  VISUAL
  AUDITORY
  KINESTHETIC
  READING_WRITING
  COLLABORATIVE
  INDEPENDENT
  SOLO
  MIXED
}

model User {
  id            String   @id @default(uuid())
  email         String   @unique
  passwordHash  String? // null if OAuth only
  name          String
  avatarUrl     String?
  coverPhotoUrl String?
  role          UserRole @default(FREE)
  emailVerified Boolean  @default(false)

  // OAuth
  googleId    String? @unique
  microsoftId String? @unique

  // Stripe
  stripeCustomerId     String?   @unique
  stripeSubscriptionId String?   @unique
  subscriptionStatus   String? // active, canceled, past_due, etc.
  subscriptionEndsAt   DateTime?

  // Account Deactivation
  deactivatedAt DateTime? // When account was deactivated (null if active)
  deactivationReason String? @db.Text // Optional reason for deactivation

  // Two-Factor Authentication
  twoFactorEnabled Boolean @default(false)
  twoFactorSecret String? // TOTP secret (encrypted)
  twoFactorBackupCodes String[] @default([]) // Backup codes for recovery

  // Admin System (CEO Control Panel)
  isAdmin Boolean @default(false) // Whether user has admin access
  isSuperAdmin Boolean @default(false) // Super admin - can manage other admins, cannot be banned
  adminGrantedAt DateTime? // When admin access was granted
  adminGrantedBy String? // Who granted admin access (user ID)

  // Timestamps
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  lastLoginAt DateTime?

  // Relations
  profile               Profile?
  learningProfile       LearningProfile?
  settings              UserSettings?
  sentMatches           Match[]              @relation("SentMatches")
  receivedMatches       Match[]              @relation("ReceivedMatches")
  sentMessages          Message[]            @relation("SentMessages")
  groupMemberships      GroupMember[]
  sessions              Session[]
  badges                UserBadge[]
  studySessions         StudySession[]       @relation("SessionUser")
  createdSessions       StudySession[]       @relation("SessionCreator")
  sessionParticipations SessionParticipant[]
  sessionMessages       SessionMessage[]
  sessionNotes          SessionNote[]
  notifications         Notification[]
  focusSessionParticipations FocusSessionParticipant[]
  posts                 Post[]
  postLikes             PostLike[]
  postComments          PostComment[]
  postReposts           PostRepost[]
  blockedUsers          BlockedUser[]        @relation("UserBlocks")
  blockedByUsers        BlockedUser[]        @relation("BlockedByUser")
  sessionFlashcards     SessionFlashcard[]

  // Presence system relations
  presence              UserPresence?
  deviceSessions        DeviceSession[]
  messageReadStatus     MessageReadStatus[]
  typingIndicators      TypingIndicator[]

  // Admin system relations
  adminAuditLogs        AdminAuditLog[]      @relation("AdminActions")
  createdAnnouncements  Announcement[]       @relation("CreatedAnnouncements")
  reportsFiled          Report[]             @relation("ReportsFiled")
  reportsAgainst        Report[]             @relation("ReportsAgainst")
  reportsHandled        Report[]             @relation("ReportsHandled")

  // Feedback relations
  feedbackSubmitted     Feedback[]           @relation("UserFeedback")
  feedbackReviewed      Feedback[]           @relation("FeedbackReviewer")

  // Push notification subscriptions
  pushSubscriptions     PushSubscription[]

  // AI Partner preferences
  hideAIPartner         Boolean  @default(false) // User chose to hide AI Partner from dashboard

  @@index([email])
  @@index([googleId])
  @@index([role])
  @@index([deactivatedAt])
  @@index([twoFactorEnabled])
  @@index([isAdmin])
  @@index([createdAt]) // PERF: Sort users by registration date (admin dashboard)
  @@index([lastLoginAt]) // PERF: Active user queries
}

model Profile {
  id     String @id @default(uuid())
  userId String @unique
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Core profile
  bio       String? @db.Text
  age       Int? // User's age
  role      String? // User's role/position (e.g., "Student", "Graduate Student", "Software Engineer")
  timezone  String?

  // DEPRECATED: Old location fields (keep for backward compatibility)
  location  String?
  latitude  Float?
  longitude Float?

  // NEW: Hybrid Location System
  location_city          String? // City from auto-detect or manual entry
  location_state         String? // State/region from auto-detect or manual entry
  location_country       String? // Country from auto-detect or manual entry
  location_lat           Float? // Latitude for proximity matching (privacy-safe)
  location_lng           Float? // Longitude for proximity matching (privacy-safe)
  location_visibility    String  @default("match-only") // 'private', 'match-only', or 'public'
  location_last_updated  DateTime? // When location was last updated

  // Academic/Learning
  subjects   String[] // ["Math", "Physics", "CS"]
  interests  String[] // ["ML", "Gaming", "Music"]
  goals      String[] // ["Prep for SAT", "Build portfolio"]
  skillLevel SkillLevel? // Optional
  studyStyle StudyStyle? // Optional
  school     String? @db.Text // Custom school name
  languages  String? @db.Text // Custom languages (comma-separated or free text)

  // Availability
  availableDays  String[] // ["Monday", "Wednesday"]
  availableHours String[] // ["18:00-20:00", "09:00-12:00"]

  // Custom Descriptions for Partner Search
  subjectCustomDescription      String? @db.Text
  skillLevelCustomDescription   String? @db.Text
  studyStyleCustomDescription   String? @db.Text
  interestsCustomDescription    String? @db.Text
  availabilityCustomDescription String? @db.Text

  // NEW: Add more about yourself
  aboutYourselfItems String[] @default([]) // Custom tags/items
  aboutYourself      String?  @db.Text // Detailed description

  // Status
  isLookingForPartner Boolean      @default(false)

  // Privacy
  showLocation Boolean @default(false)
  showEmail    Boolean @default(false)

  // Community Settings
  postPrivacy PostPrivacy @default(PUBLIC)

  // Gamification
  studyStreak     Int       @default(0)
  totalStudyHours Float     @default(0)
  lastStudyDate   DateTime?
  totalPoints     Int       @default(0) // XP earned from sessions

  // Notifications
  emailNotifications Boolean @default(true)
  pushNotifications  Boolean @default(true)

  // AI embeddings for semantic matching (enable with pgvector extension)
  embedding Unsupported("vector(1536)")? // OpenAI text-embedding-3-small dimension

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([subjects])
  @@index([interests])
  @@index([location_city])
  @@index([location_visibility])
  @@index([isLookingForPartner]) // PERF: Critical for partner matching
}

model LearningProfile {
  id     String @id @default(uuid())
  userId String @unique
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Strengths and Weaknesses for Partner Matching
  strengths        String[] @default([]) // Topics/skills user excels at: ["Calculus", "Essay Writing", "Programming"]
  weaknesses       String[] @default([]) // Topics/skills user struggles with: ["Statistics", "Grammar", "Algorithms"]
  recommendedFocus String[] @default([]) // AI-generated recommendations: ["Practice word problems", "Review theorems"]

  // Analytics (from buildLearningProfile tool)
  analytics      Json?     // Performance breakdown, topic averages, etc.
  lastComputedAt DateTime? // When the profile was last analyzed

  // Learning Metrics (for future analytics)
  learningVelocity    Float?  @default(1.0) // How fast they learn (0.5 = slow, 2.0 = fast)
  retentionRate       Float?  @default(0.7) // How well they retain info (0-1 scale)
  preferredDifficulty String? // "easy", "medium", "hard", "adaptive"

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([strengths])
  @@index([weaknesses])
}

// ==========================================
// MATCHING & CONNECTIONS
// ==========================================

enum MatchStatus {
  PENDING
  ACCEPTED
  REJECTED
  CANCELLED
}

model Match {
  id String @id @default(uuid())

  senderId String
  sender   User   @relation("SentMatches", fields: [senderId], references: [id], onDelete: Cascade)

  receiverId String
  receiver   User   @relation("ReceivedMatches", fields: [receiverId], references: [id], onDelete: Cascade)

  status  MatchStatus @default(PENDING)
  message String?     @db.Text

  // AI Match Score
  compatibilityScore Float? // 0-100
  matchReason        String? @db.Text // AI-generated explanation

  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  respondedAt DateTime?

  @@unique([senderId, receiverId])
  @@index([senderId, status])
  @@index([receiverId, status])
  @@index([status]) // PERF: Filter matches by status across all users (admin dashboard)
}

// ==========================================
// GROUPS
// ==========================================

enum GroupPrivacy {
  PUBLIC
  PRIVATE
  INVITE_ONLY
}

model Group {
  id                          String       @id @default(uuid())
  name                        String
  description                 String?      @db.Text
  subject                     String
  subjectCustomDescription    String?      @db.Text
  skillLevel                  String? // Beginner, Intermediate, Advanced, Expert
  skillLevelCustomDescription String?      @db.Text
  avatarUrl                   String?
  privacy                     GroupPrivacy @default(PUBLIC)
  maxMembers                  Int          @default(10)

  ownerId String

  // Soft delete fields
  isDeleted Boolean   @default(false)
  deletedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  members  GroupMember[]
  messages Message[]
  invites  GroupInvite[]

  @@index([subject])
  @@index([privacy])
  @@index([ownerId])
  @@index([isDeleted])
  @@index([deletedAt])
}

enum MemberRole {
  OWNER
  ADMIN
  MEMBER
}

model GroupMember {
  id String @id @default(uuid())

  groupId String
  group   Group  @relation(fields: [groupId], references: [id], onDelete: Cascade)

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  role MemberRole @default(MEMBER)

  joinedAt DateTime @default(now())

  @@unique([groupId, userId])
  @@index([userId])
  @@index([groupId])
}

enum InviteStatus {
  PENDING
  ACCEPTED
  DECLINED
}

model GroupInvite {
  id String @id @default(uuid())

  groupId String
  group   Group  @relation(fields: [groupId], references: [id], onDelete: Cascade)

  inviterId String // User who sent the invite
  inviteeId String // User who received the invite

  status  InviteStatus @default(PENDING)
  message String?      @db.Text

  createdAt   DateTime  @default(now())
  respondedAt DateTime?

  @@unique([groupId, inviteeId])
  @@index([inviteeId, status])
  @@index([groupId])
  @@index([inviterId]) // PERF: Find invites sent by a user
}

// ==========================================
// MESSAGING
// ==========================================

enum MessageType {
  TEXT
  IMAGE
  FILE
  SYSTEM
  CALL
}

enum CallType {
  AUDIO
  VIDEO
}

enum CallStatus {
  STARTED
  COMPLETED
  MISSED
  CANCELLED
  DECLINED
}

model Message {
  id      String      @id @default(uuid())
  content String      @db.Text
  type    MessageType @default(TEXT)

  // Sender - nullable to preserve messages when user deletes account
  senderId String?
  sender   User?   @relation("SentMessages", fields: [senderId], references: [id], onDelete: SetNull)

  // Cached sender info - preserved even after account deletion for admin dashboard
  senderName      String?  // Sender's name at time of sending
  senderEmail     String?  // Sender's email for admin investigation
  senderAvatarUrl String?  // Sender's avatar URL

  // Either DM or Group message
  groupId String?
  group   Group?  @relation(fields: [groupId], references: [id], onDelete: Cascade)

  recipientId String? // For DMs
  // Cached recipient info for DMs - preserved after deletion
  recipientName   String?
  recipientEmail  String?

  // Attachments
  fileUrl  String?
  fileName String?
  fileSize Int?

  // Status
  isRead      Boolean   @default(false)
  readAt      DateTime?
  deliveredAt DateTime? // New field for delivery status
  isEdited    Boolean   @default(false)

  // Call metadata (only for CALL type messages)
  callType      CallType?
  callDuration  Int? // Duration in seconds
  callStatus    CallStatus?
  callStartedAt DateTime?

  // Soft delete fields
  isDeleted Boolean   @default(false)
  deletedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Presence system relations
  readBy        MessageReadStatus[]

  // Individual indexes
  @@index([senderId])
  @@index([groupId])
  @@index([recipientId])
  @@index([createdAt])
  @@index([deliveredAt]) // New index for delivery status
  @@index([isDeleted])
  @@index([deletedAt])
  // Critical composite indexes for performance
  @@index([senderId, recipientId, createdAt]) // DM message loading
  @@index([groupId, createdAt]) // Group message loading
  @@index([recipientId, isRead]) // Unread count queries for DMs
  @@index([groupId, isRead]) // Unread count queries for groups
  @@index([senderId, recipientId, groupId]) // Message filtering
  @@index([groupId, isRead, createdAt]) // PERF: Unread group messages
  @@index([senderId, createdAt, isDeleted]) // PERF: User's sent messages
  @@index([readAt]) // PERF: Unread message queries
}

// New model for per-user conversation archives
model ConversationArchive {
  id               String    @id @default(uuid())
  userId           String
  conversationType String // 'partner' or 'group'
  conversationId   String // partner userId or groupId
  isArchived       Boolean   @default(false)
  archivedAt       DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, conversationType, conversationId])
  @@index([userId])
  @@index([conversationId])
}

// ==========================================
// STUDY SESSIONS
// ==========================================

enum SessionType {
  SOLO
  ONE_ON_ONE
  GROUP
  AI_PARTNER  // AI-powered temporary study partner session
}

// Partner type for study sessions
enum PartnerType {
  HUMAN       // Real human partner
  AI          // AI-powered study partner (OpenAI)
  SCRIPTED    // Rule-based scripted partner (future)
}

enum SessionStatus {
  WAITING    // New: Waiting lobby state (30 min timeout)
  SCHEDULED  // Legacy: kept for backward compatibility
  ACTIVE     // Call is in progress
  COMPLETED  // Call has ended
  CANCELLED  // Call was cancelled
}

enum SessionRole {
  HOST
  CO_HOST
  PARTICIPANT
}

enum ParticipantStatus {
  INVITED
  JOINED
  LEFT
  REMOVED
}

model StudySession {
  id          String        @id @default(uuid())
  title       String
  description String?       @db.Text
  type        SessionType
  status      SessionStatus @default(WAITING) // Start in waiting lobby

  // Creator/Host
  createdBy String
  creator   User   @relation("SessionCreator", fields: [createdBy], references: [id], onDelete: Cascade)

  // Legacy field (keep for backward compatibility)
  userId String
  user   User   @relation("SessionUser", fields: [userId], references: [id], onDelete: Cascade)

  // Session Metadata
  subject         String?
  tags            String[] @default([])
  maxParticipants Int      @default(10)
  isPublic        Boolean  @default(false)

  // AI Partner fields
  partnerType     PartnerType? // HUMAN, AI, or SCRIPTED
  aiPersonaId     String?      // Reference to AI persona template
  isAISession     Boolean      @default(false) // Quick check for AI sessions

  // Timing
  scheduledAt       DateTime?
  waitingStartedAt  DateTime  @default(now()) // When waiting lobby was created
  waitingExpiresAt  DateTime? // Auto-calculated: waitingStartedAt + 30 minutes
  startedAt         DateTime? // When call actually started (null until "Start" is clicked)
  endedAt           DateTime?
  durationMinutes   Int?

  // Video/Audio room
  roomId       String?
  agoraChannel String? @unique
  recordingUrl String?

  // Relations
  participants SessionParticipant[]
  goals        SessionGoal[]
  messages     SessionMessage[]
  timer        SessionTimer?
  whiteboard   SessionWhiteboard?
  notes        SessionNote[]
  flashcards   SessionFlashcard[]
  aiMessages   AIPartnerMessage[] // AI partner chat messages
  aiSession    AIPartnerSession?  // AI partner session details

  // Soft delete (user deletes - hidden from user but visible to admin)
  deletedByUserId  String?
  deletedByUserAt  DateTime?
  // Hard delete (admin deletes - permanently removed)
  deletedByAdminId String?
  deletedByAdminAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([createdBy])
  @@index([userId])
  @@index([status])
  @@index([type])
  @@index([startedAt])
  @@index([agoraChannel])
  @@index([deletedByUserAt])
  @@index([deletedByAdminAt])
  @@index([isAISession])
  @@index([partnerType])
  // PERFORMANCE: Composite indexes for common filter combinations
  @@index([status, isPublic, startedAt]) // For public session discovery
  @@index([status, type]) // For filtered session lists
  @@index([createdAt]) // For sorting by creation date
  @@index([createdBy, status]) // PERF: Find user's sessions by status
  @@index([waitingExpiresAt]) // PERF: Session expiration cleanup
}

model SessionParticipant {
  id        String       @id @default(uuid())
  sessionId String
  session   StudySession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  role   SessionRole       @default(PARTICIPANT)
  status ParticipantStatus @default(INVITED)

  joinedAt  DateTime?
  leftAt    DateTime?
  createdAt DateTime  @default(now())

  @@unique([sessionId, userId])
  @@index([userId])
  @@index([sessionId])
  @@index([status])
  @@index([sessionId, status]) // PERF: Find active participants in a session
  @@index([joinedAt]) // PERF: Participant tracking
  @@index([leftAt]) // PERF: Participant tracking
}

model SessionGoal {
  id        String       @id @default(uuid())
  sessionId String
  session   StudySession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  title       String
  description String?   @db.Text
  isCompleted Boolean   @default(false)
  completedAt DateTime?
  order       Int       @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([sessionId])
}

model SessionMessage {
  id        String       @id @default(uuid())
  sessionId String
  session   StudySession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  senderId String
  sender   User   @relation(fields: [senderId], references: [id], onDelete: Cascade)

  content String      @db.Text
  type    MessageType @default(TEXT)

  createdAt DateTime @default(now())
  deletedAt DateTime?

  @@index([sessionId])
  @@index([senderId])
  @@index([createdAt])
  @@index([deletedAt])
  @@index([sessionId, createdAt]) // PERF: Session messages pagination (most common query)
}

enum TimerState {
  IDLE
  RUNNING
  PAUSED
  BREAK
  BREAK_PAUSED
}

model SessionTimer {
  id        String       @id @default(uuid())
  sessionId String       @unique
  session   StudySession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  // Timer Settings
  studyDuration Int // Study duration in minutes
  breakDuration Int // Break duration in minutes

  // Current State
  state         TimerState @default(IDLE)
  timeRemaining Int // Remaining seconds
  currentCycle  Int        @default(1) // Study Session 1, 2, 3...
  isBreakTime   Boolean    @default(false)

  // Tracking
  lastStartedAt  DateTime?
  lastPausedAt   DateTime?
  totalStudyTime Int       @default(0) // Total study seconds accumulated
  totalBreakTime Int       @default(0) // Total break seconds accumulated

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([sessionId])
}

// ==========================================
// GAMIFICATION
// ==========================================

enum BadgeType {
  STUDY_STREAK
  HOURS_LOGGED
  PARTNERSHIPS
  QUIZZES_PASSED
  SPECIAL
}

model Badge {
  id          String    @id @default(uuid())
  name        String    @unique
  description String
  type        BadgeType
  iconUrl     String
  requirement Int // e.g., 7 for 7-day streak

  users UserBadge[]

  @@index([type])
}

model UserBadge {
  id String @id @default(uuid())

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  badgeId String
  badge   Badge  @relation(fields: [badgeId], references: [id], onDelete: Cascade)

  earnedAt DateTime @default(now())

  @@unique([userId, badgeId])
  @@index([userId])
}

// ==========================================
// NOTIFICATIONS
// ==========================================

enum NotificationType {
  MATCH_REQUEST
  MATCH_ACCEPTED
  MATCH_DECLINED
  NEW_MESSAGE
  GROUP_INVITE
  GROUP_REMOVED
  GROUP_OWNERSHIP_RECEIVED  // User became group owner
  GROUP_OWNERSHIP_CHANGED   // Group ownership was transferred
  STUDY_REMINDER
  BADGE_EARNED
  STREAK_REMINDER
  CONNECTION_REQUEST
  CONNECTION_ACCEPTED
  CONNECTION_DECLINED
  SESSION_INVITE
  SESSION_STARTED
  SESSION_JOINED
  SESSION_ENDED
  SESSION_GOAL_COMPLETED
  INCOMING_CALL
  FOCUS_SESSION_INVITE      // Quick focus session invitation
  ANNOUNCEMENT           // Critical app announcements
  POST_LIKE              // Someone liked user's post
  POST_COMMENT           // Someone commented on user's post
  POST_REPOST            // Someone reposted user's post
  FOUNDER_MESSAGE        // Messages from founder
}

model Notification {
  id String @id @default(uuid())

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  type    NotificationType
  title   String
  message String           @db.Text

  isRead    Boolean @default(false)
  actionUrl String?

  // Reference to related entities
  relatedUserId  String? // ID of the user who triggered the notification
  relatedMatchId String? // ID of the match/connection request

  // Flexible metadata for different notification types (e.g., call details)
  metadata Json? // Stores callType, messageId, callerName, callerAvatar, etc.

  createdAt DateTime @default(now())

  @@index([userId, isRead])
  @@index([createdAt])
  @@index([userId, createdAt]) // PERF: Paginated notification queries sorted by date
  @@index([relatedUserId]) // PERF: Related user lookups
}

// Push Subscriptions for Web Push Notifications
model PushSubscription {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Web Push subscription data
  endpoint  String   @unique // Push service endpoint URL
  p256dh    String   // Client public key
  auth      String   // Auth secret

  // Device/browser info
  userAgent String?  @db.Text
  deviceName String? // e.g., "Chrome on Windows", "Safari on iPhone"

  // Status tracking
  isActive  Boolean  @default(true)
  lastUsed  DateTime @default(now())
  failCount Int      @default(0) // Track failed push attempts

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([endpoint])
  @@index([isActive])
}

// ==========================================
// SESSIONS (NextAuth)
// ==========================================

model Session {
  id     String @id @default(uuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  token     String   @unique
  expiresAt DateTime

  createdAt DateTime @default(now())

  @@index([userId])
  @@index([token])
}

// ==========================================
// COMMUNITY (Social Feed like X/Twitter)
// ==========================================

enum PostPrivacy {
  PUBLIC         // Everyone can see
  PARTNERS_ONLY  // Only connected partners can see
}

model Post {
  id      String @id @default(uuid())
  userId  String
  user    User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  content   String  @db.Text // Post text content
  imageUrls String[] // Array of image URLs
  postUrl   String? // Optional link/URL to external content

  // Soft delete fields
  isDeleted Boolean   @default(false) // Soft delete flag
  deletedAt DateTime? // When post was deleted (null if not deleted)

  // Share settings
  allowSharing Boolean @default(true) // Allow post to be shared outside the app

  // Interaction settings - post owner can disable comments/likes
  allowComments Boolean @default(true) // Allow users to comment on this post
  allowLikes    Boolean @default(true) // Allow users to like this post

  // Relations
  likes    PostLike[]
  comments PostComment[]
  reposts  PostRepost[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([createdAt])
  @@index([isDeleted])
  @@index([deletedAt])
  // Composite index for feed queries (fetch non-deleted posts by user or all users)
  @@index([isDeleted, createdAt])
  @@index([userId, isDeleted, createdAt])
}

model PostLike {
  id     String @id @default(uuid())
  postId String
  post   Post   @relation(fields: [postId], references: [id], onDelete: Cascade)
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([postId, userId]) // User can only like a post once
  @@index([postId])
  @@index([userId])
}

model PostComment {
  id      String @id @default(uuid())
  postId  String
  post    Post   @relation(fields: [postId], references: [id], onDelete: Cascade)
  userId  String
  user    User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  content String @db.Text

  // Threading/Replies - 1 level deep (comment -> reply)
  parentId String?       // If this is a reply, points to parent comment
  parent   PostComment?  @relation("CommentReplies", fields: [parentId], references: [id], onDelete: Cascade)
  replies  PostComment[] @relation("CommentReplies")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([postId])
  @@index([userId])
  @@index([createdAt])
  @@index([parentId])
}

model PostRepost {
  id      String  @id @default(uuid())
  postId  String
  post    Post    @relation(fields: [postId], references: [id], onDelete: Cascade)
  userId  String
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  comment String? @db.Text // Optional comment for "quote repost"

  createdAt DateTime @default(now())

  @@unique([postId, userId]) // User can only repost once
  @@index([postId])
  @@index([userId])
  @@index([createdAt])
}

// ==========================================
// USER SETTINGS
// ==========================================

enum ProfileVisibility {
  EVERYONE
  CONNECTIONS_ONLY
  PRIVATE
}

enum DataSharing {
  MINIMAL
  STANDARD
  FULL
}

enum NotificationFrequency {
  REALTIME
  DIGEST_DAILY
  DIGEST_WEEKLY
  OFF
}

enum FlashcardFrequency {
  DAILY
  WEEKLY
  CUSTOM
}

enum VideoQuality {
  AUTO
  LOW
  MEDIUM
  HIGH
}

enum SessionInvitePrivacy {
  EVERYONE
  CONNECTIONS
  NOBODY
}

enum GroupPrivacyDefault {
  PUBLIC
  PRIVATE
  INVITE_ONLY
}

enum FeedAlgorithm {
  RECOMMENDED
  CHRONOLOGICAL
  TRENDING
}

enum CommentPrivacy {
  EVERYONE
  CONNECTIONS
  NOBODY
}

enum Theme {
  LIGHT
  DARK
  SYSTEM
}

enum FontSize {
  SMALL
  MEDIUM
  LARGE
  XLARGE
}

enum ColorBlindMode {
  NONE
  PROTANOPIA
  DEUTERANOPIA
  TRITANOPIA
}

enum PerformanceMode {
  LOW_POWER
  BALANCED
  PERFORMANCE
}

model UserSettings {
  id     String @id @default(uuid())
  userId String @unique
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Account & Profile
  language String? @default("en")
  timezone String? @default("UTC")

  // Privacy & Visibility
  profileVisibility ProfileVisibility @default(EVERYONE)
  searchVisibility  Boolean           @default(true)
  showOnlineStatus  Boolean           @default(true)
  showLastSeen      Boolean           @default(true)
  dataSharing       DataSharing       @default(STANDARD)

  // Notification Preferences - In-App
  notifyConnectionRequests Boolean @default(true)
  notifyConnectionAccepted Boolean @default(true)
  notifySessionInvites     Boolean @default(true)
  notifyGroupInvites       Boolean @default(true)
  notifyMessages           Boolean @default(true)
  notifyMissedCalls        Boolean @default(true)
  notifyCommunityActivity  Boolean @default(true)
  notifySessionReminders   Boolean @default(true)

  // Email Notifications
  emailConnectionRequests Boolean @default(true)
  emailSessionInvites     Boolean @default(true)
  emailMessages           Boolean @default(false)
  emailWeeklySummary      Boolean @default(true)

  // Notification Frequency
  notificationFrequency NotificationFrequency @default(REALTIME)

  // Do Not Disturb
  doNotDisturbEnabled Boolean @default(false)
  doNotDisturbStart   String? // e.g., "22:00"
  doNotDisturbEnd     String? // e.g., "08:00"

  // Study Preferences
  defaultStudyDuration     Int                 @default(25) // minutes
  defaultBreakDuration     Int                 @default(5) // minutes
  preferredSessionLength   Int                 @default(60) // minutes
  autoGenerateQuizzes      Boolean             @default(false)
  flashcardReviewFrequency FlashcardFrequency? @default(DAILY)

  // Communication Settings
  messageReadReceipts    Boolean      @default(true)
  typingIndicators       Boolean      @default(true)
  autoDownloadMedia      Boolean      @default(true)
  videoQuality           VideoQuality @default(AUTO)
  audioQuality           VideoQuality @default(AUTO)
  enableVirtualBackground Boolean     @default(false)

  // Call Settings
  autoAnswerFromPartners Boolean @default(false)
  callRingtone           String? @default("default")

  // Study Session Settings
  autoStartTimer           Boolean               @default(false)
  breakReminders           Boolean               @default(true)
  sessionHistoryRetention  Int                   @default(90) // days
  sessionInvitePrivacy     SessionInvitePrivacy  @default(EVERYONE)

  // Group Settings
  defaultGroupPrivacy  GroupPrivacyDefault   @default(PUBLIC)
  groupNotifications   Boolean               @default(true)
  autoJoinMatchingGroups Boolean             @default(false)
  groupInvitePrivacy   SessionInvitePrivacy  @default(EVERYONE)

  // Content & Community
  feedAlgorithm       FeedAlgorithm  @default(RECOMMENDED)
  showTrendingTopics  Boolean        @default(true)
  commentPrivacy      CommentPrivacy @default(EVERYONE)
  tagPrivacy          CommentPrivacy @default(EVERYONE)
  contentFiltering    String[]       @default([])

  // Accessibility
  theme           Theme           @default(SYSTEM)
  fontSize        FontSize        @default(MEDIUM)
  highContrast    Boolean         @default(false)
  reducedMotion   Boolean         @default(false)
  keyboardShortcuts Boolean       @default(true)
  colorBlindMode  ColorBlindMode  @default(NONE)

  // Data & Storage
  cacheEnabled       Boolean @default(true)
  autoBackup         Boolean @default(true)
  storageUsageLimit  Int     @default(1000) // MB

  // Integrations
  googleCalendarSync Boolean @default(false)
  googleCalendarId   String?

  // Advanced
  developerMode     Boolean         @default(false)
  betaFeatures      Boolean         @default(false)
  performanceMode   PerformanceMode @default(BALANCED)
  analyticsEnabled  Boolean         @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
}

// Blocked Users for Privacy
model BlockedUser {
  id            String @id @default(uuid())
  userId        String
  user          User   @relation("UserBlocks", fields: [userId], references: [id], onDelete: Cascade)
  blockedUserId String
  blockedUser   User   @relation("BlockedByUser", fields: [blockedUserId], references: [id], onDelete: Cascade)
  reason        String?

  createdAt DateTime @default(now())

  @@unique([userId, blockedUserId])
  @@index([userId])
  @@index([blockedUserId])
}

// ==========================================
// STUDY SESSION COLLABORATION FEATURES
// ==========================================

// Whiteboard - Real-time collaborative drawing
model SessionWhiteboard {
  id        String       @id @default(uuid())
  sessionId String       @unique
  session   StudySession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  // Metadata
  title       String @default("Untitled Whiteboard")
  description String?

  // Storage references (Supabase Storage)
  snapshotUrl  String? // URL to latest full whiteboard snapshot
  thumbnailUrl String? // Small preview thumbnail

  // Real-time sync metadata
  lastSyncedAt  DateTime @default(now())
  lastEditedBy  String? // User ID who last edited
  version       Int      @default(1)

  // Relations
  versions SessionWhiteboardVersion[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([sessionId])
  @@index([lastSyncedAt])
}

// Whiteboard version history
model SessionWhiteboardVersion {
  id           String            @id @default(uuid())
  whiteboardId String
  whiteboard   SessionWhiteboard @relation(fields: [whiteboardId], references: [id], onDelete: Cascade)

  version     Int    // Version number (incremental)
  snapshotUrl String // Supabase Storage URL for this version
  createdBy   String // User ID who created this version

  createdAt DateTime @default(now())

  @@index([whiteboardId])
  @@index([whiteboardId, version])
  @@index([createdAt])
}

// Private Notes - Each user has their own private notes per session
// Notes are only visible to the owner unless shared to screen
model SessionNote {
  id        String       @id @default(uuid())
  sessionId String
  session   StudySession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  // Owner - each user has their own private notes
  userId String
  user   User @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Metadata
  title String @default("My Notes")

  // Content (stored in DB if < 64KB, otherwise in Storage)
  content    String? @db.Text // Null if stored in Storage
  contentUrl String? // Supabase Storage URL for large content

  // Privacy - notes are private by default
  // Sharing is done via screen share, not database access

  // Auto-save tracking
  lastEditedAt DateTime @default(now())

  // Versioning for conflict resolution
  version Int @default(1)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Unique constraint: one note per user per session
  @@unique([sessionId, userId])
  @@index([sessionId])
  @@index([userId])
  @@index([lastEditedAt])
}

// Flashcards - Per-user study cards with spaced repetition
model SessionFlashcard {
  id        String       @id @default(uuid())
  sessionId String
  session   StudySession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  userId String // Per-user flashcards (not shared)
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Card content
  front String @db.Text
  back  String @db.Text

  // Study tracking
  difficulty     Int       @default(0) // 0=easy, 1=medium, 2=hard
  lastReviewed   DateTime?
  reviewCount    Int       @default(0)
  correctCount   Int       @default(0)
  incorrectCount Int       @default(0)

  // Spaced repetition (SM-2 algorithm)
  nextReviewDate DateTime? // When this card should be reviewed next
  intervalDays   Int       @default(1) // Current interval in days
  easeFactor     Float     @default(2.5) // SM-2 ease factor (2.5 is default)
  repetitions    Int       @default(0) // Number of successful reviews in a row

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([id])
  @@index([sessionId, userId])
  @@index([userId, nextReviewDate]) // For querying due cards
  @@index([createdAt])
}

// ==========================================
// PRESENCE SYSTEM (Real-time Online/Offline Tracking)
// ==========================================

// Aggregate user presence status (one per user)
model UserPresence {
  id              String   @id @default(uuid())
  userId          String   @unique
  status          String   @default("offline") // "online" | "away" | "offline"
  activityType    String   @default("browsing") // "browsing" | "studying" | "in_call" | "with_ai" | "idle"
  activityDetails String?  // JSON: { sessionId, subject, startedAt, etc. }
  lastSeenAt      DateTime @default(now())
  lastActivityAt  DateTime @default(now())
  isPrivate       Boolean  @default(false) // Privacy setting: hide online status
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([status])
  @@index([activityType]) // For filtering by activity type
  @@index([lastSeenAt]) // For presence timeout/cleanup queries
  @@index([status, lastSeenAt]) // For finding stale online users
  @@index([lastActivityAt]) // PERF: Cleanup stale presence records
  @@map("user_presence")
}

// Individual device/tab sessions (multiple per user)
model DeviceSession {
  id              String   @id @default(uuid())
  userId          String
  deviceId        String   // Client-generated UUID (persists across refreshes in localStorage)
  lastHeartbeatAt DateTime @default(now())
  isActive        Boolean  @default(true)
  userAgent       String?  // Browser/device info
  ipAddress       String?  // For security logging
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, deviceId])
  @@index([userId, isActive])
  @@index([lastHeartbeatAt])
  @@index([isActive, lastHeartbeatAt]) // PERF: For cleanup queries finding stale active sessions
  @@index([userId, updatedAt]) // PERF: For fetching user's recent sessions
  @@map("device_sessions")
}

// Message read receipts
model MessageReadStatus {
  id          String   @id @default(uuid())
  messageId   String
  userId      String   // Who read the message
  readAt      DateTime @default(now())
  createdAt   DateTime @default(now())

  // Relations
  message     Message  @relation(fields: [messageId], references: [id], onDelete: Cascade)
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([messageId, userId])
  @@index([messageId])
  @@index([userId])
  @@map("message_read_status")
}

// Typing indicators (short-lived, auto-expire after 10s)
model TypingIndicator {
  id             String   @id @default(uuid())
  userId         String   // Who is typing
  conversationId String   // Where they're typing (chatId or studySessionId)
  isTyping       Boolean  @default(true)
  expiresAt      DateTime // Auto-delete after 10 seconds
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  // Relations
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, conversationId])
  @@index([conversationId, expiresAt])
  @@index([userId]) // PERF: Clear typing indicators when user disconnects
  @@index([expiresAt]) // PERF: For cleanup cron jobs deleting expired indicators
  @@map("typing_indicators")
}

// ==========================================
// RLS POLICIES (SQL to be run after migration)
// ==========================================
//
// -- Enable RLS on all collaboration tables
// ALTER TABLE "SessionWhiteboard" ENABLE ROW LEVEL SECURITY;
// ALTER TABLE "SessionWhiteboardVersion" ENABLE ROW LEVEL SECURITY;
// ALTER TABLE "SessionNote" ENABLE ROW LEVEL SECURITY;
// ALTER TABLE "SessionFlashcard" ENABLE ROW LEVEL SECURITY;
//
// -- SessionWhiteboard RLS: Users can only access whiteboards for sessions they're participants in
// CREATE POLICY "Users can view whiteboards for their sessions"
//   ON "SessionWhiteboard" FOR SELECT
//   USING (
//     EXISTS (
//       SELECT 1 FROM "SessionParticipant"
//       WHERE "SessionParticipant"."sessionId" = "SessionWhiteboard"."sessionId"
//       AND "SessionParticipant"."userId" = auth.uid()::text
//     )
//   );
//
// CREATE POLICY "Users can update whiteboards for their sessions"
//   ON "SessionWhiteboard" FOR UPDATE
//   USING (
//     EXISTS (
//       SELECT 1 FROM "SessionParticipant"
//       WHERE "SessionParticipant"."sessionId" = "SessionWhiteboard"."sessionId"
//       AND "SessionParticipant"."userId" = auth.uid()::text
//     )
//   );
//
// CREATE POLICY "Session hosts can insert whiteboards"
//   ON "SessionWhiteboard" FOR INSERT
//   WITH CHECK (
//     EXISTS (
//       SELECT 1 FROM "StudySession"
//       WHERE "StudySession"."id" = "SessionWhiteboard"."sessionId"
//       AND "StudySession"."createdBy" = auth.uid()::text
//     )
//   );
//
// CREATE POLICY "Session hosts can delete whiteboards"
//   ON "SessionWhiteboard" FOR DELETE
//   USING (
//     EXISTS (
//       SELECT 1 FROM "StudySession"
//       WHERE "StudySession"."id" = "SessionWhiteboard"."sessionId"
//       AND "StudySession"."createdBy" = auth.uid()::text
//     )
//   );
//
// -- SessionWhiteboardVersion RLS
// CREATE POLICY "Users can view whiteboard versions for their sessions"
//   ON "SessionWhiteboardVersion" FOR SELECT
//   USING (
//     EXISTS (
//       SELECT 1 FROM "SessionWhiteboard" wb
//       INNER JOIN "SessionParticipant" sp ON wb."sessionId" = sp."sessionId"
//       WHERE wb."id" = "SessionWhiteboardVersion"."whiteboardId"
//       AND sp."userId" = auth.uid()::text
//     )
//   );
//
// CREATE POLICY "Users can create whiteboard versions for their sessions"
//   ON "SessionWhiteboardVersion" FOR INSERT
//   WITH CHECK (
//     EXISTS (
//       SELECT 1 FROM "SessionWhiteboard" wb
//       INNER JOIN "SessionParticipant" sp ON wb."sessionId" = sp."sessionId"
//       WHERE wb."id" = "SessionWhiteboardVersion"."whiteboardId"
//       AND sp."userId" = auth.uid()::text
//     )
//   );
//
// -- SessionNote RLS: Similar to whiteboard
// CREATE POLICY "Users can view notes for their sessions"
//   ON "SessionNote" FOR SELECT
//   USING (
//     EXISTS (
//       SELECT 1 FROM "SessionParticipant"
//       WHERE "SessionParticipant"."sessionId" = "SessionNote"."sessionId"
//       AND "SessionParticipant"."userId" = auth.uid()::text
//     )
//   );
//
// CREATE POLICY "Users can update notes for their sessions"
//   ON "SessionNote" FOR UPDATE
//   USING (
//     EXISTS (
//       SELECT 1 FROM "SessionParticipant"
//       WHERE "SessionParticipant"."sessionId" = "SessionNote"."sessionId"
//       AND "SessionParticipant"."userId" = auth.uid()::text
//     )
//   );
//
// CREATE POLICY "Session hosts can insert notes"
//   ON "SessionNote" FOR INSERT
//   WITH CHECK (
//     EXISTS (
//       SELECT 1 FROM "StudySession"
//       WHERE "StudySession"."id" = "SessionNote"."sessionId"
//       AND "StudySession"."createdBy" = auth.uid()::text
//     )
//   );
//
// CREATE POLICY "Session hosts can delete notes"
//   ON "SessionNote" FOR DELETE
//   USING (
//     EXISTS (
//       SELECT 1 FROM "StudySession"
//       WHERE "StudySession"."id" = "SessionNote"."sessionId"
//       AND "StudySession"."createdBy" = auth.uid()::text
//     )
//   );
//
// -- SessionFlashcard RLS: Users can only access their own flashcards
// CREATE POLICY "Users can view their own flashcards"
//   ON "SessionFlashcard" FOR SELECT
//   USING ("userId" = auth.uid()::text);
//
// CREATE POLICY "Users can insert their own flashcards"
//   ON "SessionFlashcard" FOR INSERT
//   WITH CHECK (
//     "userId" = auth.uid()::text
//     AND EXISTS (
//       SELECT 1 FROM "SessionParticipant"
//       WHERE "SessionParticipant"."sessionId" = "SessionFlashcard"."sessionId"
//       AND "SessionParticipant"."userId" = auth.uid()::text
//     )
//   );
//
// CREATE POLICY "Users can update their own flashcards"
//   ON "SessionFlashcard" FOR UPDATE
//   USING ("userId" = auth.uid()::text);
//
// CREATE POLICY "Users can delete their own flashcards"
//   ON "SessionFlashcard" FOR DELETE
//   USING ("userId" = auth.uid()::text);

// ==========================================
// ADMIN SYSTEM (CEO Control Panel)
// ==========================================

// Admin Audit Log - Track all admin actions for accountability
model AdminAuditLog {
  id        String   @id @default(uuid())
  adminId   String?  // Nullable to preserve audit logs when admin is deleted
  admin     User?    @relation("AdminActions", fields: [adminId], references: [id], onDelete: SetNull)

  // Cached admin info - preserved even after admin account deletion for accountability
  adminName  String?  // Admin's name at time of action
  adminEmail String?  // Admin's email for identification

  action    String   // e.g., "user_banned", "post_deleted", "announcement_created"
  targetType String  // e.g., "user", "post", "group", "message"
  targetId  String   // ID of the affected entity
  details   Json?    // Additional context/details as JSON
  ipAddress String?  // IP address for security tracking
  userAgent String?  // Browser/device info

  createdAt DateTime @default(now())

  @@index([adminId])
  @@index([action])
  @@index([targetType])
  @@index([createdAt])
}

// System Announcements - Messages from CEO/Admin to all users
enum AnnouncementPriority {
  LOW
  NORMAL
  HIGH
  URGENT
}

enum AnnouncementStatus {
  DRAFT
  ACTIVE
  SCHEDULED
  ARCHIVED
}

model Announcement {
  id          String               @id @default(uuid())
  title       String
  content     String               @db.Text
  priority    AnnouncementPriority @default(NORMAL)
  status      AnnouncementStatus   @default(DRAFT)

  // Targeting
  targetAll   Boolean              @default(true) // Show to all users
  targetRole  String?              // Target specific role (FREE, PREMIUM)
  targetUserIds String[]           @default([]) // Specific user IDs to target (in addition to role targeting)

  // Display settings
  showBanner  Boolean              @default(false) // Show as top banner
  ctaLabel    String?              // Call-to-action button text
  ctaUrl      String?              // Call-to-action URL

  // Scheduling
  startsAt    DateTime?
  expiresAt   DateTime?

  // Metadata
  createdById String               // Admin user ID who created
  createdBy   User                 @relation("CreatedAnnouncements", fields: [createdById], references: [id], onDelete: Cascade)
  createdAt   DateTime             @default(now())
  updatedAt   DateTime             @updatedAt

  // Track who has seen/dismissed
  dismissals  AnnouncementDismissal[]

  @@index([status])
  @@index([priority])
  @@index([startsAt])
  @@index([expiresAt])
}

model AnnouncementDismissal {
  id             String       @id @default(uuid())
  announcementId String
  announcement   Announcement @relation(fields: [announcementId], references: [id], onDelete: Cascade)
  userId         String
  dismissedAt    DateTime     @default(now())

  @@unique([announcementId, userId])
  @@index([userId])
}

// User Reports - For content moderation
enum ReportType {
  SPAM
  HARASSMENT
  INAPPROPRIATE_CONTENT
  FAKE_ACCOUNT
  SCAM
  HATE_SPEECH
  VIOLENCE
  OTHER
}

enum ReportStatus {
  PENDING
  REVIEWING
  RESOLVED
  DISMISSED
}

model Report {
  id          String       @id @default(uuid())

  // Who filed the report
  reporterId  String
  reporter    User         @relation("ReportsFiled", fields: [reporterId], references: [id], onDelete: Cascade)

  // Who/what is being reported
  reportedUserId String?   // If reporting a user
  reportedUser   User?     @relation("ReportsAgainst", fields: [reportedUserId], references: [id], onDelete: SetNull)

  // What type of content
  contentType String       // "user", "post", "message", "group", "comment"
  contentId   String       // ID of the reported content

  // Report details
  type        ReportType
  description String?      @db.Text
  evidence    String[]     @default([]) // URLs to screenshots, etc.

  // Admin handling
  status      ReportStatus @default(PENDING)
  handledById String?
  handledBy   User?        @relation("ReportsHandled", fields: [handledById], references: [id], onDelete: SetNull)
  handledAt   DateTime?
  resolution  String?      @db.Text // Admin notes on resolution
  actionTaken String?      // What action was taken (warning, ban, content_removed, etc.)

  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt

  @@index([reporterId])
  @@index([reportedUserId])
  @@index([contentType, contentId])
  @@index([status])
  @@index([type])
  @@index([createdAt])
  @@index([handledById]) // PERF: Find reports handled by a specific admin
  @@index([status, createdAt]) // PERF: Pending reports
  @@unique([reporterId, reportedUserId, contentType, contentId]) // PERF: Prevent duplicate reports
}

// User Warnings - Track warnings issued to users
model UserWarning {
  id          String   @id @default(uuid())
  userId      String
  issuedById  String   // Admin who issued the warning
  reason      String   @db.Text
  severity    Int      @default(1) // 1 = mild, 2 = moderate, 3 = severe
  reportId    String?  // Optional link to related report

  // Expiration (some warnings expire)
  expiresAt   DateTime?

  createdAt   DateTime @default(now())

  @@index([userId])
  @@index([issuedById])
  @@index([createdAt])
}

// User Bans - Track temporary and permanent bans
enum BanType {
  TEMPORARY
  PERMANENT
}

model UserBan {
  id          String   @id @default(uuid())
  userId      String   @unique // One active ban per user
  issuedById  String   // Admin who issued the ban
  type        BanType
  reason      String   @db.Text
  reportId    String?  // Optional link to related report

  // For temporary bans
  expiresAt   DateTime?

  // For appeals
  appealMessage String? @db.Text
  appealedAt  DateTime?
  appealStatus String? // "pending", "approved", "denied"

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([userId])
  @@index([issuedById])
  @@index([type])
  @@index([expiresAt])
}

// ==========================================
// CONTENT MODERATION
// ==========================================

enum ContentType {
  DIRECT_MESSAGE  // Partner/DM messages
  GROUP_MESSAGE   // Group chat messages
  SESSION_MESSAGE // Study session chat
  POST            // Community posts
  COMMENT         // Post comments
}

enum ModerationStatus {
  PENDING   // Awaiting review
  APPROVED  // Content is acceptable
  REMOVED   // Content was removed
  WARNING   // User was warned
}

enum FlagReason {
  AI_DETECTED      // Automatically flagged by AI
  USER_REPORTED    // Reported by another user
  KEYWORD_MATCH    // Matched banned keywords
  MANUAL_REVIEW    // Flagged by admin for review
}

// Flagged Content - Messages/posts flagged for moderation
model FlaggedContent {
  id            String           @id @default(uuid())

  // Content reference (polymorphic)
  contentType   ContentType
  contentId     String           // ID of the message/post
  content       String           @db.Text // Cached content for review

  // Who sent the content
  senderId      String
  senderEmail   String?
  senderName    String?

  // Conversation context
  conversationId String?         // Group ID, partner ID, or session ID
  conversationType String?       // "group", "partner", "session"

  // Flag details
  flagReason    FlagReason
  flaggedAt     DateTime         @default(now())

  // AI moderation results (from OpenAI)
  aiCategories  Json?            // Categories flagged by AI (sexual, violence, hate, etc.)
  aiScore       Float?           // Confidence score 0-1

  // Admin review
  status        ModerationStatus @default(PENDING)
  reviewedById  String?          // Admin who reviewed
  reviewedAt    DateTime?
  reviewNotes   String?          @db.Text
  actionTaken   String?          // "none", "deleted", "warned", "banned"

  createdAt     DateTime         @default(now())
  updatedAt     DateTime         @updatedAt

  @@index([status])
  @@index([contentType])
  @@index([senderId])
  @@index([flaggedAt])
  @@index([contentType, status])
  @@index([senderId, status, flaggedAt]) // PERF: User's flagged content
  @@map("flagged_content")
}

// ==========================================
// USER ACTIVITY TRACKING (Analytics & Behavioral)
// ==========================================

// Page Visit Tracking
model UserPageVisit {
  id          String   @id @default(uuid())
  userId      String

  // Page info
  path        String   // e.g., "/search", "/messages", "/profile"
  pageName    String?  // Human readable name e.g., "Find Partner", "Messages"
  referrer    String?  // Where user came from

  // Session info
  sessionId   String?  // Browser session ID
  deviceId    String?  // Device session ID

  // Timing
  enteredAt   DateTime @default(now())
  exitedAt    DateTime? // When user left the page
  duration    Int?     // Time spent in seconds

  // Context
  query       String?  // URL query params

  createdAt   DateTime @default(now())

  @@index([userId])
  @@index([path])
  @@index([createdAt])
  @@index([userId, path])
  @@index([userId, createdAt])
  @@map("user_page_visits")
}

// Feature Usage Tracking
model UserFeatureUsage {
  id          String   @id @default(uuid())
  userId      String

  // Feature info
  feature     String   // e.g., "partner_search", "send_message", "create_post"
  category    String   // e.g., "matching", "messaging", "community", "profile"
  action      String   // e.g., "click", "submit", "view", "create", "update", "delete"

  // Target info (optional)
  targetType  String?  // e.g., "user", "post", "group", "session"
  targetId    String?  // ID of the target entity

  // Additional data
  metadata    Json?    // Any additional context

  createdAt   DateTime @default(now())

  @@index([userId])
  @@index([feature])
  @@index([category])
  @@index([createdAt])
  @@index([userId, feature])
  @@index([userId, createdAt])
  @@map("user_feature_usage")
}

// Search Query Tracking
model UserSearchQuery {
  id          String   @id @default(uuid())
  userId      String

  // Search info
  query       String   // The search query
  searchType  String   // "partner", "group", "post", "message"

  // Filters applied
  filters     Json?    // Any filters used (subjects, skill level, etc.)

  // Results
  resultCount Int?     // Number of results returned
  clickedResults String[] @default([]) // IDs of results user clicked

  // Context
  pagePath    String?  // Where the search was performed

  createdAt   DateTime @default(now())

  @@index([userId])
  @@index([searchType])
  @@index([createdAt])
  @@index([userId, createdAt])
  @@map("user_search_queries")
}

// User Session Analytics (aggregate stats per session)
model UserSessionAnalytics {
  id              String   @id @default(uuid())
  userId          String
  sessionId       String   @unique // Browser session ID

  // Session timing
  startedAt       DateTime @default(now())
  endedAt         DateTime?
  totalDuration   Int?     // Total session duration in seconds
  activeTime      Int      @default(0) // Time user was actively engaged (not idle)

  // Page stats
  pagesVisited    Int      @default(0)
  uniquePages     Int      @default(0)

  // Feature usage
  featuresUsed    Int      @default(0)
  searchesMade    Int      @default(0)
  messagesSent    Int      @default(0)
  postsCreated    Int      @default(0)

  // Device info
  deviceId        String?
  userAgent       String?
  ipAddress       String?

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([userId])
  @@index([sessionId])
  @@index([startedAt])
  @@index([userId, startedAt])
  @@map("user_session_analytics")
}

// Suspicious Activity Log
enum SuspiciousActivityType {
  RAPID_MESSAGING       // Sending many messages too quickly (spam)
  DUPLICATE_CONTENT     // Posting same content multiple times
  MASS_CONNECTION_REQUESTS // Sending too many connection requests
  LOGIN_FROM_NEW_LOCATION // Login from unusual location
  MULTIPLE_FAILED_LOGINS  // Multiple failed login attempts
  PROFILE_SPAM          // Suspicious profile content
  UNUSUAL_SEARCH_PATTERN // Unusual search behavior
  CONTENT_FLAGGED       // Content flagged by AI moderation
  RAPID_REPORTING       // Filing many reports in short time
  BULK_ACTIONS          // Too many actions in short time
}

enum SuspiciousActivitySeverity {
  LOW       // Just tracking, no action needed
  MEDIUM    // Review recommended
  HIGH      // Action recommended
  CRITICAL  // Immediate action required
}

model SuspiciousActivityLog {
  id          String   @id @default(uuid())
  userId      String

  // Activity details
  type        SuspiciousActivityType
  severity    SuspiciousActivitySeverity @default(LOW)

  // Context
  description String   @db.Text
  metadata    Json?    // Additional context data

  // Detection info
  detectedBy  String   // "system", "ai", "admin", "rate_limiter"
  confidence  Float?   // 0-1 confidence score (for AI detection)

  // Related entities
  relatedType String?  // "message", "post", "connection_request", etc.
  relatedId   String?  // ID of the related entity

  // Admin handling
  isReviewed  Boolean  @default(false)
  reviewedById String?
  reviewedAt  DateTime?
  actionTaken String?  // What action was taken if any

  // IP/Device tracking
  ipAddress   String?
  userAgent   String?
  deviceId    String?

  createdAt   DateTime @default(now())

  @@index([userId])
  @@index([type])
  @@index([severity])
  @@index([isReviewed])
  @@index([createdAt])
  @@index([userId, type])
  @@index([severity, isReviewed])
  @@index([severity, isReviewed, createdAt]) // PERF: Admin review priority
  @@map("suspicious_activity_logs")
}

// User Activity Summary (daily aggregates for dashboard)
model UserActivitySummary {
  id              String   @id @default(uuid())
  userId          String
  date            DateTime @db.Date // Day of activity

  // Session stats
  totalSessions   Int      @default(0)
  totalDuration   Int      @default(0) // Total time in seconds
  avgSessionLength Int     @default(0)

  // Page views
  totalPageViews  Int      @default(0)
  uniquePageViews Int      @default(0)

  // Feature usage
  searchCount     Int      @default(0)
  messagesSent    Int      @default(0)
  messagesReceived Int     @default(0)
  postsCreated    Int      @default(0)
  postsLiked      Int      @default(0)
  commentsCreated Int      @default(0)
  connectionsSent Int      @default(0)
  connectionsAccepted Int  @default(0)
  groupsJoined    Int      @default(0)
  sessionsJoined  Int      @default(0)

  // Engagement metrics
  profileViews    Int      @default(0) // Views of this user's profile by others
  engagementScore Float    @default(0) // Calculated engagement metric

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@unique([userId, date])
  @@index([userId])
  @@index([date])
  @@index([userId, date])
  @@map("user_activity_summaries")
}

// ==========================================
// USER FEEDBACK
// ==========================================

enum FeedbackStatus {
  PENDING
  REVIEWED
  RESOLVED
  ARCHIVED
}

model Feedback {
  id          String         @id @default(uuid())

  // Who submitted the feedback
  userId      String
  user        User           @relation("UserFeedback", fields: [userId], references: [id], onDelete: Cascade)

  // Feedback content
  rating      Int            // 1-5 star rating
  message     String         @db.Text
  screenshots String[]       @default([]) // URLs to uploaded screenshots

  // Admin handling
  status      FeedbackStatus @default(PENDING)
  reviewedById String?
  reviewedBy  User?          @relation("FeedbackReviewer", fields: [reviewedById], references: [id], onDelete: SetNull)
  reviewedAt  DateTime?
  adminNotes  String?        @db.Text

  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt

  @@index([userId])
  @@index([status])
  @@index([rating])
  @@index([createdAt])
}

// ==========================================
// AI PARTNER SYSTEM (Temporary Study Partner)
// ==========================================

// AI Partner Persona Templates - Defines AI behavior and personality
model AIPartnerPersona {
  id          String   @id @default(uuid())
  name        String   // e.g., "Study Buddy", "Quiz Master", "Calm Tutor"
  description String   @db.Text

  // Persona configuration
  systemPrompt  String   @db.Text // The system prompt for OpenAI
  temperature   Float    @default(0.7) // OpenAI temperature (0-1)
  maxTokens     Int      @default(500) // Max response length

  // Specializations
  subjects      String[] @default([]) // Subjects this persona excels at
  studyMethods  String[] @default([]) // ["pomodoro", "quiz", "explanation", "practice"]
  tone          String   @default("friendly") // "friendly", "professional", "casual", "encouraging"

  // Display
  avatarUrl     String?
  isDefault     Boolean  @default(false) // Default persona for new sessions
  isActive      Boolean  @default(true)  // Can be used

  // Stats
  usageCount    Int      @default(0)
  avgRating     Float?

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations
  sessions      AIPartnerSession[]

  @@index([isDefault])
  @@index([isActive])
  @@index([subjects])
}

// AI Partner Session - Tracks each AI partner study session
model AIPartnerSession {
  id          String       @id @default(uuid())

  // User who started the session
  userId      String

  // Link to study session
  studySessionId String?   @unique
  studySession   StudySession? @relation(fields: [studySessionId], references: [id], onDelete: Cascade)

  // Persona used
  personaId   String?
  persona     AIPartnerPersona? @relation(fields: [personaId], references: [id], onDelete: SetNull)

  // Session context
  subject     String?      // Current study subject
  skillLevel  SkillLevel?  // User's skill level for this session
  studyGoal   String?      @db.Text // What user wants to achieve
  searchCriteria Json?     // Full search criteria used to start session (subjects, location, interests, etc.)

  // Session state
  status      AISessionStatus @default(ACTIVE)

  // Timing
  startedAt   DateTime     @default(now())
  endedAt     DateTime?
  totalDuration Int?       // Total session duration in seconds (from start to end)
  focusTime     Int?       // Pomodoro focus time in seconds (only when timer was running)

  // Session stats
  messageCount  Int        @default(0)
  quizCount     Int        @default(0) // Number of quizzes generated
  flashcardCount Int       @default(0) // Number of flashcards created

  // User feedback
  rating        Int?       // 1-5 star rating
  feedback      String?    @db.Text

  // Moderation
  flaggedCount  Int        @default(0) // Number of flagged messages
  wasSafetyBlocked Boolean @default(false) // Session was ended due to safety

  // Intelligence System (v2.0+)
  intelligenceVersion String?    // Version of intelligence system used
  adaptiveState       Json?      // Serialized adaptive tracker state
  totalTokensUsed     Int        @default(0) // Token budget tracking
  fallbackCallCount   Int        @default(0) // AI fallback calls used

  // Soft delete (user deletes - hidden from user but visible to admin)
  deletedByUserId  String?
  deletedByUserAt  DateTime?
  // Hard delete (admin deletes - permanently removed)
  deletedByAdminId String?
  deletedByAdminAt DateTime?

  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt

  // Relations
  messages    AIPartnerMessage[]

  @@index([userId])
  @@index([status])
  @@index([startedAt])
  @@index([personaId])
  @@index([userId, status]) // PERF: Find user's active/paused sessions
  @@index([deletedByUserAt])
  @@index([deletedByAdminAt])
  @@index([endedAt]) // PERF: Completed session queries
}

enum AISessionStatus {
  ACTIVE      // Session is ongoing
  PAUSED      // User paused the session
  COMPLETED   // Session ended normally
  EXPIRED     // Session timed out
  BLOCKED     // Ended due to safety violation
}

// AI Partner Messages - Chat history with AI
model AIPartnerMessage {
  id          String       @id @default(uuid())

  // Session reference
  sessionId   String
  session     AIPartnerSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  // Also link to study session for easier queries
  studySessionId String?
  studySession   StudySession? @relation(fields: [studySessionId], references: [id], onDelete: Cascade)

  // Message content
  role        AIMessageRole // USER or ASSISTANT
  content     String       @db.Text

  // Message type
  messageType AIMessageType @default(CHAT)

  // For quiz messages
  quizData    Json?        // Quiz question data (question, options, answer)

  // For flashcard generation
  flashcardData Json?      // Generated flashcard data

  // For image messages (upload or generated)
  imageUrl      String?    // URL of the image (uploaded or generated)
  imageBase64   String?    @db.Text // Base64 encoded image data (for uploaded images)
  imageMimeType String?    // MIME type of the image (e.g., 'image/png', 'image/jpeg')
  imageType     String?    // 'uploaded' or 'generated'
  imagePrompt   String?    @db.Text // For generated images: the prompt used
  imageAnalysis Json?      // Analysis result for uploaded images

  // Moderation
  wasModerated  Boolean    @default(false) // Was this message checked by moderation
  moderationResult Json?   // OpenAI moderation API result
  wasFlagged    Boolean    @default(false) // Was flagged as inappropriate
  flagCategories String[]  @default([]) // Which categories were flagged

  // Token usage tracking
  promptTokens     Int?
  completionTokens Int?
  totalTokens      Int?

  createdAt   DateTime     @default(now())

  @@index([sessionId])
  @@index([studySessionId])
  @@index([role])
  @@index([createdAt])
  @@index([wasFlagged])
  @@index([sessionId, createdAt]) // PERF: Load messages in chronological order
}

enum AIMessageRole {
  USER       // Message from the user
  ASSISTANT  // Message from the AI
  SYSTEM     // System message (e.g., session started, topic changed)
}

enum AIMessageType {
  CHAT       // Regular chat message
  QUIZ       // Quiz question or answer
  FLASHCARD  // Flashcard generation
  SUMMARY    // Session summary or notes
  TIMER      // Timer-related message (pomodoro encouragement)
  TOPIC_CHANGE // User changed study topic
  WHITEBOARD // Whiteboard analysis response
  IMAGE      // Image upload or AI-generated image
}

// ==========================================
// AI MEMORY SYSTEM (Persistent User Context)
// ==========================================

// User memory - Long-term storage of user preferences and context
model AIUserMemory {
  id          String   @id @default(uuid())
  userId      String   @unique // One memory per user

  // Basic User Preferences (extracted from conversations)
  preferredName       String?  // How they like to be called
  preferredLearningStyle String? // visual, auditory, reading/writing, hands-on
  preferredDifficulty String?  // easy, medium, hard, adaptive
  preferredPace       String?  // slow, normal, fast
  timezone            String?  // User's timezone for scheduling references

  // Academic Context
  currentSubjects     String[] @default([]) // Subjects actively studying
  masteredTopics      String[] @default([]) // Topics they've mastered
  strugglingTopics    String[] @default([]) // Topics they struggle with
  upcomingExams       Json?    // [{subject, date, notes}]
  academicGoals       String[] @default([]) // Long-term goals

  // Personality & Communication
  communicationStyle  String?  // formal, casual, encouraging, direct
  motivationalNeeds   String?  // needs_encouragement, self_motivated, competitive
  humorPreference     String?  // likes_jokes, serious_only, occasional

  // Study Habits (learned over time)
  bestStudyTime       String?  // morning, afternoon, evening, night
  avgSessionLength    Int?     // Average session length in minutes
  breakPreference     String?  // frequent_short, long_sessions, pomodoro

  // Interaction History Summary
  totalSessions       Int      @default(0)
  totalStudyMinutes   Int      @default(0)
  lastSessionDate     DateTime?
  streakDays          Int      @default(0)
  longestStreak       Int      @default(0)

  // Important Facts (AI-extracted key information)
  importantFacts      Json?    // [{fact, category, extractedAt}]

  // Session Continuity
  lastTopicDiscussed  String?  // For continuity between sessions
  pendingQuestions    String[] @default([]) // Questions to follow up on

  // AI Behavior Customization
  customInstructions  String?  @db.Text // User-provided custom instructions

  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  @@index([userId])
  @@map("ai_user_memory")
}

// Memory entries - Individual memory items for retrieval
model AIMemoryEntry {
  id          String   @id @default(uuid())
  userId      String

  // Memory classification
  category    AIMemoryCategory
  importance  Int      @default(5) // 1-10 scale

  // Content
  content     String   @db.Text // The memory itself
  context     String?  @db.Text // Context where this was learned

  // Source tracking
  sessionId   String?  // Which session this came from
  messageId   String?  // Which message this was extracted from

  // Retrieval metadata
  lastAccessed DateTime?
  accessCount  Int      @default(0)

  // Validity
  isActive    Boolean  @default(true)
  expiresAt   DateTime? // Some memories can expire

  // Embeddings for semantic search (enable with pgvector)
  embedding   Unsupported("vector(1536)")? // For semantic similarity search

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([userId])
  @@index([category])
  @@index([importance])
  @@index([userId, category])
  @@index([userId, isActive])
  @@map("ai_memory_entries")
}

enum AIMemoryCategory {
  PREFERENCE          // User preferences (learning style, pace, etc.)
  ACADEMIC            // Academic info (subjects, exams, grades)
  PERSONAL_FACT       // Personal facts about user
  STUDY_HABIT         // Study habits and patterns
  ACHIEVEMENT         // Accomplishments and milestones
  STRUGGLE            // Areas they struggle with
  GOAL                // Goals and aspirations
  FEEDBACK            // Feedback they've given
  CONVERSATION_TOPIC  // Notable topics discussed
}

// ==========================================
// AI RESPONSE CACHING (Enhanced for Smart Routing)
// ==========================================

model AIResponseCache {
  id          String   @id @default(uuid())

  // Query identification
  queryHash       String   @unique  // SHA256 hash for exact matching
  queryNormalized String   @db.Text // Normalized query for fuzzy matching

  // Cached response
  response    String   @db.Text

  // Scope and ownership (hybrid caching)
  scope       String   @default("global") // 'global', 'user', 'session'
  userId      String?  // NULL for global scope
  subject     String?  // Subject context (optional)
  skillLevel  String?  // Skill level context (optional)

  // Cache management
  hitCount    Int      @default(0)    // Number of times this cache was used
  expiresAt   DateTime               // When this cache entry expires
  lastAccessedAt DateTime @default(now())

  // Metadata (JSONB for flexibility)
  // Contains: originalQuery, modelUsed, tokensUsed, responseLength, complexity
  metadata    Json     @default("{}")

  createdAt   DateTime @default(now())

  @@index([queryHash])
  @@index([scope])
  @@index([userId])
  @@index([expiresAt])
  @@index([subject])
  @@index([scope, expiresAt, hitCount])
  @@map("ai_response_cache")
}

// ==========================================
// AI USAGE MONITORING
// ==========================================

model AIUsageLog {
  id              String   @id @default(uuid())
  userId          String?
  sessionId       String?

  // Model and operation
  model           String   // gpt-4o-mini, gpt-4o, etc.
  operation       String   // chat, quiz_generation, etc.

  // Token usage
  promptTokens    Int
  completionTokens Int
  totalTokens     Int

  // Cost and performance
  estimatedCost   Float    // In USD
  latencyMs       Int      // Response time

  // Cache and status
  cached          Boolean  @default(false)
  success         Boolean  @default(true)
  errorType       String?
  errorMessage    String?  @db.Text

  // Additional context
  metadata        Json?

  createdAt       DateTime @default(now())

  @@index([userId])
  @@index([sessionId])
  @@index([model])
  @@index([operation])
  @@index([createdAt])
  @@index([success])
  @@index([cached]) // PERF: Filter cached requests
  @@index([createdAt, cached]) // PERF: Date range + cache filter
  @@index([createdAt, model]) // PERF: Date range + model filter
  @@index([createdAt, success]) // PERF: Date range + error filter
  @@index([userId, createdAt]) // PERF: User usage over time
  @@map("ai_usage_logs")
}

// Daily usage aggregation for faster queries
model AIUsageDailySummary {
  id              String   @id @default(uuid())
  date            DateTime @db.Date
  userId          String?  // null = global summary

  // Aggregated metrics
  totalRequests   Int      @default(0)
  totalTokens     Int      @default(0)
  promptTokens    Int      @default(0)
  completionTokens Int     @default(0)
  totalCost       Float    @default(0)

  // Performance
  avgLatencyMs    Int      @default(0)
  successCount    Int      @default(0)
  errorCount      Int      @default(0)
  cacheHits       Int      @default(0)

  // Breakdown by model
  tokensByModel   Json?    // { "gpt-4o-mini": 1000, ... }
  tokensByOperation Json?  // { "chat": 500, "quiz": 300, ... }

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@unique([date, userId])
  @@index([date])
  @@index([userId])
  @@map("ai_usage_daily_summaries")
}

// ==========================================
// STUDY CIRCLES (Social Accountability)
// ==========================================

enum StudyCircleStatus {
  ACTIVE
  PAUSED
  ARCHIVED
}

enum CircleMemberRole {
  OWNER
  ADMIN
  MEMBER
}

enum CircleMemberStatus {
  ACTIVE
  INVITED
  LEFT
  REMOVED
}

// Study Circle - Stable groups of 3-6 people who study together regularly
model StudyCircle {
  id              String            @id @default(uuid())
  name            String            // "CS Study Squad", "SAT Prep Group"
  description     String?           @db.Text
  coverImageUrl   String?

  // Circle settings
  maxMembers      Int               @default(6) // Max 6 for intimate accountability
  isPrivate       Boolean           @default(true) // Private by default
  inviteCode      String?           @unique // For inviting new members

  // Focus area
  subjects        String[]          // ["Math", "Physics"]
  goals           String[]          // ["Pass finals", "Study 2hrs/day"]

  // Status
  status          StudyCircleStatus @default(ACTIVE)

  // Group streak (collective accountability)
  currentStreak   Int               @default(0) // Days everyone showed up
  longestStreak   Int               @default(0)
  lastActivityAt  DateTime?         // Last time any member was active

  // Creator
  createdById     String

  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt

  // Relations
  members         StudyCircleMember[]
  scheduledSessions CircleScheduledSession[]
  attendanceRecords CircleAttendance[]

  @@index([createdById])
  @@index([status])
  @@index([inviteCode])
  @@index([currentStreak]) // For leaderboards
  @@map("study_circles")
}

// Study Circle Members
model StudyCircleMember {
  id              String              @id @default(uuid())
  circleId        String
  userId          String

  // Role and status
  role            CircleMemberRole    @default(MEMBER)
  status          CircleMemberStatus  @default(ACTIVE)

  // Member stats within this circle
  attendanceRate  Float               @default(0) // 0-100%
  totalSessions   Int                 @default(0)
  totalStudyTime  Int                 @default(0) // Minutes in this circle

  // Notifications
  notifyBeforeSession Boolean         @default(true)
  notifyOnMemberJoin  Boolean         @default(true)

  joinedAt        DateTime            @default(now())
  leftAt          DateTime?

  // Relations
  circle          StudyCircle         @relation(fields: [circleId], references: [id], onDelete: Cascade)

  @@unique([circleId, userId])
  @@index([userId])
  @@index([circleId])
  @@index([status])
  @@map("study_circle_members")
}

// Scheduled/Recurring Sessions for Circles
model CircleScheduledSession {
  id              String            @id @default(uuid())
  circleId        String

  // Session details
  title           String            // "Daily Study Session"
  description     String?           @db.Text

  // Schedule (recurring)
  isRecurring     Boolean           @default(true)
  recurringDays   String[]          // ["Monday", "Wednesday", "Friday"]
  startTime       String            // "19:00" (24hr format)
  durationMinutes Int               @default(60)
  timezone        String            @default("UTC")

  // One-time session date (if not recurring)
  scheduledDate   DateTime?

  // Status
  isActive        Boolean           @default(true)

  // Reminder settings
  reminderMinutes Int               @default(15) // Notify 15 min before

  createdById     String
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt

  // Relations
  circle          StudyCircle       @relation(fields: [circleId], references: [id], onDelete: Cascade)
  attendances     CircleAttendance[]

  @@index([circleId])
  @@index([isActive])
  @@index([createdById])
  @@map("circle_scheduled_sessions")
}

// Attendance Tracking - Who showed up to which session
model CircleAttendance {
  id              String            @id @default(uuid())
  circleId        String
  sessionId       String?           // Links to scheduled session
  userId          String

  // Attendance details
  date            DateTime          @db.Date
  joinedAt        DateTime?         // When they joined
  leftAt          DateTime?         // When they left
  durationMinutes Int               @default(0) // How long they studied

  // Status
  didAttend       Boolean           @default(false)
  wasLate         Boolean           @default(false) // Joined >10 min late

  createdAt       DateTime          @default(now())

  // Relations
  circle          StudyCircle       @relation(fields: [circleId], references: [id], onDelete: Cascade)
  scheduledSession CircleScheduledSession? @relation(fields: [sessionId], references: [id], onDelete: SetNull)

  @@unique([circleId, userId, date]) // One record per person per day per circle
  @@index([userId])
  @@index([circleId])
  @@index([date])
  @@index([didAttend])
  @@map("circle_attendance")
}

// ==========================================
// QUICK FOCUS - Zero-Motivation Entry Point
// ==========================================
// Instant focus sessions that require no setup or decision-making
// Users can start a 7-minute focus timer with one click

enum FocusSessionStatus {
  ACTIVE
  COMPLETED
  ABANDONED
}

model FocusSession {
  id        String             @id @default(uuid())
  userId    String

  // Session configuration
  durationMinutes Int          @default(7) // Default 7-minute focus

  // Timing
  startedAt       DateTime     @default(now())
  completedAt     DateTime?    // When session was completed or abandoned

  // Status tracking
  status          FocusSessionStatus @default(ACTIVE)
  actualMinutes   Int?         // Actual time spent focusing

  // Optional context (can be added during or after session)
  label           String?      // e.g., "Math", "Reading", "Work"
  notes           String?      @db.Text

  // AI Task Feature
  mode            String       @default("solo") // "solo" or "ai_guided"
  taskType        String?      // "question", "problem", "writing", "reading", "coding"
  taskSubject     String?      // User's chosen subject or custom input
  taskPrompt      String?      @db.Text // The AI-generated task
  taskDifficulty  String?      // "easy", "medium", "hard"
  userResponse    String?      @db.Text // User's answer/submission
  aiFeedback      String?      @db.Text // AI's feedback on user's response
  taskCompleted   Boolean      @default(false) // Did user mark task as done

  // Streak tracking
  contributesToStreak Boolean  @default(true)

  // Relations
  participants    FocusSessionParticipant[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([status])
  @@index([startedAt])
  @@index([userId, startedAt]) // For user's session history
  @@map("focus_sessions")
}

// FocusSessionParticipant - For collaborative quick focus sessions
model FocusSessionParticipant {
  id              String             @id @default(uuid())
  focusSessionId  String
  focusSession    FocusSession       @relation(fields: [focusSessionId], references: [id], onDelete: Cascade)

  userId          String
  user            User               @relation(fields: [userId], references: [id], onDelete: Cascade)

  role            FocusSessionRole       @default(PARTICIPANT)
  status          FocusParticipantStatus @default(INVITED)

  joinedAt        DateTime?
  leftAt          DateTime?
  createdAt       DateTime           @default(now())
  updatedAt       DateTime           @updatedAt

  @@unique([focusSessionId, userId]) // One user can only be in a focus session once
  @@index([userId])
  @@index([focusSessionId])
  @@index([status])
  @@index([focusSessionId, status]) // PERF: Find active participants in a session
  @@index([joinedAt])
  @@index([leftAt])
  @@map("focus_session_participants")
}

enum FocusSessionRole {
  HOST
  PARTICIPANT
}

enum FocusParticipantStatus {
  INVITED
  JOINED
  LEFT
  DECLINED
}

// ==========================================
// HELP & SUPPORT MESSAGES
// ==========================================

enum HelpMessageStatus {
  PENDING     // Not yet reviewed
  IN_PROGRESS // Being handled
  RESOLVED    // Issue resolved
  CLOSED      // Closed without resolution
}

enum HelpMessagePriority {
  LOW
  NORMAL
  HIGH
  URGENT
}

// Support messages from users submitted via Help page
model HelpMessage {
  id            String              @id @default(uuid())

  // Sender information (can be anonymous/logged-out users)
  userId        String?             // NULL if submitted by non-logged-in user
  name          String              // Name provided in form
  email         String              // Email for response

  // Message content
  subject       String
  message       String              @db.Text

  // Categorization
  category      String?             // "bug", "feature", "account", "billing", "other"
  priority      HelpMessagePriority @default(NORMAL)

  // Status tracking
  status        HelpMessageStatus   @default(PENDING)

  // Admin handling
  assignedToId  String?             // Admin handling this ticket
  resolvedById  String?             // Admin who resolved it
  resolvedAt    DateTime?

  // Admin notes (internal)
  adminNotes    String?             @db.Text

  // Response tracking
  responseCount Int                 @default(0) // Number of responses sent
  lastResponseAt DateTime?

  // Metadata for spam prevention and analytics
  ipAddress     String?             // For rate limiting
  userAgent     String?             // Browser/device info

  createdAt     DateTime            @default(now())
  updatedAt     DateTime            @updatedAt

  @@index([userId])
  @@index([status])
  @@index([priority])
  @@index([email])
  @@index([createdAt])
  @@index([assignedToId])
  @@index([status, priority]) // For admin dashboard filtering
  @@index([status, createdAt]) // For sorting pending messages by date
  @@map("help_messages")
}
